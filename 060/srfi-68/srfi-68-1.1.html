<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<body>
<head>
<title>SRFI 68: Comprehensive I/O</title>
</head>

<body>
<H1>Title</H1>

Comprehensive I/O

<H1>Authors</H1>

Michael Sperber


<H1>Status</H1>

This SRFI is currently in ``draft'' status. To see an explanation of each
status that a SRFI can hold, see
<A HREF="http://srfi.schemers.org/srfi-process.html">here</A>.
It will remain in draft status until 2005/06/13, or as amended. To
provide input on this SRFI, please <CODE>
<A HREF="mailto:srfi-68@srfi.schemers.org">mailto:srfi-68@srfi.schemers.org</A></CODE>.
See <A HREF="../../srfi-list-subscribe.html">instructions
here</A> to subscribe to the list. You can access previous messages via
<A HREF="http://srfi.schemers.org/srfi-68/mail-archive/maillist.html">the
archive of the mailing list</A>.
<P>
<ul>
  <li>Received: 2005/04/06</li>
  <li>Draft: 2005/04/13 - 2005/06/13</li>
</ul>


<h1>Abstract</h1>
<p>This SRFI defines a comprehensive I/O subsystem for Scheme with three layers, where each layer is built on top of the one below it:</p><ul><li>The lowest, primitive layer provides unbuffered I/O, and is close to what a typical operating system offers.</li><li>The middle layer builds on lazy, mostly functional buffered streams.</li><li>The upper layer is similar in nature to the ports subsystem in R5RS, and provides conventional, imperative buffered input and output.</li></ul><p>The layer architecture is similar to the upper three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a>.</p><p>In particular, the subsystem provides</p><ul><li>buffered reading and writing</li><li>arbitrary lookahead at the streams level</li><li>dynamic redirection of input or output at the ports level</li><li>binary and text I/O, mixed if needed</li><li>translated data streams</li><li>unbuffered I/O at the primitive layer</li><li>the ability to create arbitrary I/O streams, such to and from byte vectors and strings</li></ul><p>The subsystem does <em>not</em> provide</p><ul><li>formatted I/O</li><li>non-blocking or selective I/O</li><li>portable filenames, or any functionality for manipulating filenames</li><li>filesystem operations</li><li>socket I/O</li><li>extremely high-throughput or zero-copy I/O</li></ul><p>However, all of these could be added on top of one or several of the layers specified in this SRFI.</p>

<h1>Rationale</h1>
<p>The I/O subsystem in R5RS is too limited in many respects:  It only provides for for text I/O, it only allows reading at the character and the datum level, and some of the primitives are mis-designed or underspecified.  As a result, almost every Scheme implementation has its own extensions to the I/O system, and rarely are two of these extensions compatible.</p><p>This SRFI is meant as a compelling replacement for the R5RS I/O subsystem.  As such, it is a completely new design, and it is not based on the extensions a particular existing Scheme system provides.  (In fact, it is probably, in its entirety, unlike what any existing Scheme system provides.)  Moreover, it is meant to be a substrate for further extensions which can be built on top of the subsystem via the interface described here.</p><p>The design of this SRFI is driven by the requirements mentioned in the abstract on the one hand, and on the excellent design of the I/O subsystem in the Standard ML Basis Library. The is latter is also the reason why this SRFI is different from the extensions provided by any existing Scheme implementation, as none of them picked up on the Basis design, and because the Basis design seems superior to the extensions I have looked at.  (Among those I have looked at are Scheme 48, scsh, Gambit-C, and PLT Scheme.)</p><p>Note, however, that this SRFI differs from the SML Basis in several important respects, among the handling of textual I/O streams, the ability to define translated streams, and the absence of any functionality related to non-blocking I/O.  The latter is more properly in the domain of a thread/even system; Concurrent ML shows that the SML Basis plays well with such a system, and I expect the same to hold true here.  The text encoding/translation functionality is different mainly because it plays to a different substrate for representing text (based on Unicode; see below) than Standard ML.</p><p>Like the Standard ML Basis I/O subsystem, the I/O system specified in this SRFI is probably not suitable for maximal-throughput I/O, chiefly because it does not re-use buffers, and because the buffer objects are byte vectors, with no further constraints on alignment or GC behavior.  However, I deemed the achievable performance as more than adequate for most applications---it seemed a small price to pay for the convenient programming model.</p>

<h1>Specification</h1>
<h2>Prerequisites</h2><p>This SRFI is meant for Scheme implementations with the following prerequisites:</p><ul><li>support for SRFIs <a href="http://srfi.schemers.org/srfi-34/">34</a> (Exception Handling for Programs), <a href="http://srfi.schemers.org/srfi-35/">35</a> (Conditions), <a href="http://srfi.schemers.org/srfi-66/">66</a> (Byte Vectors)</li><li>Unicode support</li></ul><h2>Unicode support</h2><p>This SRFI assumes that the <code>char</code> datatype in Scheme to correspond to Unicode scalar values.  This, in turn, means that strings are represented as vectors of scalar values. (Note that this is consistent with <a href="http://srfi.schemers.org/srfi-14/">14</a> (Character-set library).) It may be possible to make this SRFI work in an ASCII- or Latin-1-only system, but I have not made any special provisions to ensure this.</p><h2>Filenames</h2><p>Some of the procedures described here accept a filename <var>filename</var> as an argument.  Valid values for such a filename include strings naming a file using the native notation of the operating system the Scheme implementation happens to be running on.</p><p>It is expected that a future SRFI will extend this set of values by a more abstract representation: This is necessary, as the most common operating systems do not really use strings for representing filenames, but rather byte sequences.  Moreover, the string notation is difficult to manipulate and not very portable.</p><h2>General remarks</h2><p>For procedures that have no &quot;natural&quot; return value, this SRFI often uses the sentence</p><p><em>The return values are unspecified.</em></p><p>This means that number of return values  and the return values are unspecified.  However, the number of return values  is such that it is accepted by a continuation created by <code>begin</code>.  Specifically, on Scheme implementations where continuations created by <code>begin</code> accept an arbitrary number of arguments (this includes most implementations), it is suggested that the procedure return zero return values.</p><h2>Organization</h2><p>The I/O subsystem consists of three layers.  Each layer can function independently from those above it.  Moreover, each layer can be used without referring directly to the ones below it.  Therefore, a Scheme implementation with a module system should offer each layer as an independent module.  Moreover, some data extensions are common to all three I/O layers---specifically, the common I/O condition types.</p><h3>Data extensions</h3><h4>Condition types</h4><p>The I/O conditition type hierarchy here is similar, but not identical to the one described in <a href="http://srfi.schemers.org/srfi-36/">36</a> (I/O Conditions).</p><p>The following list depicts the I/O condition hierarchy; more detailed explanations of the condition types follow.</p><ul><li><code>&amp;error</code><br><ul><li><code>&amp;i/o-error</code><br><ul><li><code>&amp;i/o-read-error</code></li><li><code>&amp;i/o-write-error</code></li><li><code>&amp;i/o-closed-error</code></li><li><code>&amp;i/o-invalid-position-error</code></li></ul><br><ul><li><code>&amp;i/o-filename-error</code> (has a <code>filename</code> field)<br><ul><li><code>&amp;i/o-malformed-filename-error</code></li><li><code>&amp;i/o-file-protection-error</code><br><ul><li><code>&amp;i/o-file-is-read-only-error</code></li></ul></li><li><code>&amp;i/o-file-already-exists-error</code></li><li><code>&amp;i/o-no-such-file-error</code></li></ul></li></ul></li></ul></li></ul><p>In exceptional situations not described as &quot;it is an error&quot;, the procedures described in the specification below will raise an <code>&amp;i/o-error</code> condition object.  Except where explicitly specified, there is no guarantee that the raised condition object will contain all the information that would be applicable.  It is recommended, however, that an implementation of this SRFI provide all information about an exceptional situation in the condition object that is available at the place where it is detected.</p><dl><dt><pre>(define-condition-type &amp;i/o-error &amp;error
  i/o-error?)
</pre></dt><dd><p>This is a supertype for a set of more specific I/O errors.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-read-error &amp;i/o-error
  i/o-read-error?)
</pre></p></dt><dd><p>This condition type specifies a read error that occurred during an I/O operation.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-write-error &amp;i/o-error
  i/o-write-error?)
</pre></p></dt><dd><p>This condition type specifies a write error that occurred during an I/O operation.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-invalid-position-error &amp;i/o-error
  i/o-invalid-position-error?
  (position i/o-error-position))
</pre></p></dt><dd><p>This condition type specifies that an attempt to set the file position specified an invalid position.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-closed-error &amp;i/o-error
  i/o-error?)
</pre></p></dt><dd><p>A condition of this type specifies that an operation tried to operate on a closed I/O object under the assumption that it is open.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-filename-error &amp;i/o-error
  i/o-filename-error?
  (filename i/o-error-filename))
</pre></p></dt><dd><p>This condition type specifies an I/O error that occurred during an operation on a named file.  Condition objects belonging to this type must specify a file name in the <code>filename</code> field.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-malformed-filename-error &amp;i/o-filename-error
  i/o-malformed-filename-error?)
</pre></p></dt><dd>This condition type indicates that a file name had an invalid format.</dd><dt><p><pre>(define-condition-type &amp;i/o-operation-error &amp;i/o-error
  i/o-operation-error?
  (operation i/o-error-operation))
</pre></p></dt><dd><p>This condition type specifies an I/O error that occurred during an specific operation.  Condition objects belonging to this type must specify the procedure that was called to perform the operation in the <code>operation</code> field.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-operation-not-available-error &amp;i/o-operation-error
  i/o-operation-not-available-error?)
</pre></p></dt><dd>This condition type indicates that the program tried to perform an I/O operation that was not available.</dd><dt><p><pre>(define-condition-type &amp;i/o-file-protection-error &amp;i/o-filename-error
  i/o-file-protection-error?)
</pre></p></dt><dd><p>A condition of this type specifies that an operation tried to operate on a named file with insufficient access rights.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-file-is-read-only-error &amp;i/o-file-protection-error
  i/o-file-is-read-only-error?)
</pre></p></dt><dd><p>A condition of this type specifies that an operation tried to operate on a named read-only file under the assumption that it is writeable.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-file-already-exists-error &amp;i/o-filename-error
  i/o-file-already-exists-error?)
</pre></p></dt><dd><p>A condition of this type specifies that an operation tried to operate on an existing named file under the assumption that it does not exist.</p></dd><dt><p><pre>(define-condition-type &amp;i/o-file-exists-not-error &amp;i/o-filename-error
  i/o-file-exists-not-error?)
</pre></p></dt><dd><p>A condition of this type specifies that an operation tried to operate on an non-existent named file under the assumption that it exists.</p></dd></dl><h3>Primitive I/O</h3><p>The Primitive I/O layer is an abstraction of the low-level I/O system calls commonly available on file descriptors:  Streams and ports from the upper layers of the I/O system always perform access through the abstractions provided by this layer.  The objects representing I/O descriptors are called <em>readers</em> for input and <em>writers</em> for output.  They are unbuffered and operate purely on binary data.</p><p>This layer only specifies a fairly small set of operations --- a subset of the Standard ML Basis <code>PRIM_IO</code> signature.  Specifically, all functionality related to non-blocking I/O or polling is missing here.  This is intentional, as this functionality should be integrated with the threads system of the underlying implementation, and is thus outside the scope of this (already large) SRFI.  Instead, it is expected that the set of operations available on primitive I/O readers and writers will be augmented by future specifications, as will be the available constructors for these objects.</p><p>The Primitive I/O layer introduces one condition type of its own.</p><dl><dt><p><pre>(define-condition-type &amp;i/o-reader/writer-error &amp;i/o-error
  i/o-reader/writer-error?
  (reader/writer i/o-error-reader/writer))
</pre></p></dt><dd><p>This condition type allows specifying with what particular reader or writer an I/O error is associated.  The <code>reader/writer</code> field has purely informational purpose.  Conditions raised in by Primitive I/O procedures <em>may</em> include an <code>&amp;i/o-reader/writer-error</code> condition, but are not required to do so.</p></dd></dl><h4>Readers</h4><p>A reader object typically stands for a file or device descriptor, but can also represent the output of some algorithm, such as in the case of string readers.  The sequence of bytes represented is potentially unbounded, and is punctuated by end of file elements.</p><dl><dt><code>(reader? </code><var>obj</var><code>)</code></dt><dd><p><p>Returns <code>#t</code> if <var>obj</var> is a reader, otherwise returns <code>#f</code>.</p></p></dd><dt><code>(make-simple-reader </code><var>id</var> <var>descriptor</var> <var>chunk-size</var> <var>read-byte!</var> <var>available-bytes</var> <var>get-position</var> <var>set-position!</var> <var>end-position</var> <var>close</var><code>)</code></dt><dd><p>Returns a reader object. <var>Id</var> is a string naming the reader, provided for informational purposes only.  For a file, this will be a string representation of the file name.  <var>Descriptor</var> is supposed to be the low-level object connected to the reader, such as the OS-level file descriptor or the source string in the case of a string reader.</p><p><var>Chunk-size</var> must be a positive exact integer,  and is the recommended efficient size of the read operations on this reader.  This is typically the block size of the buffers of the operating system.  Note that this is just a recommendation --- calls to the <var>read-bytes!</var> procedure (see below) will not necessarily use it.  A value of 1 represents a recommendation to use unbuffered reads.</p><p>The remaining arguments are procedures --- <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> may be omitted, in which case the corresponding arguments must be <code>#f</code>.</p><dl><dt><code>(<var>read-bytes!</var> </code><var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers.  This reads up to <var>count</var> bytes from the reader and writes them into <var>bytes</var>, which must be a byte vector, starting at index <var>start</var>.  <var>Bytes</var> must have at least <var>start</var> + <var>count</var> elements.  This procedure returns the number of bytes read as an exact integer.  It returns 0 if it encounters an end of file, or if <var>count</var> is 0.  This procedure blocks until at least one byte has been read or it has encountered end of file.</p></dd><dt><code>(<var>available-bytes</var> </code><code>)</code></dt><dd><p>This returns an estimate of the total number of available bytes left in the stream.  The return value is either an exact integer, or <code>#f</code> if no such estimate is possible.  There is no guarantee that this estimate will have any specific relationship to the true number of available bytes.</p></dd><dt><code>(<var>get-position</var> </code><code>)</code></dt><dd><p>This procedure, when present, returns the current position in the byte stream as an exact integer counting the number of bytes since the beginning of the stream.</p></dd><dt><code>(<var>set-position!</var> </code><var>pos</var><code>)</code></dt><dd><p>This procedure, when present, moves to position <var>pos</var> (which must be a non-negative exact integer) in the stream.</p></dd><dt><code>(<var>end-position</var> </code><code>)</code></dt><dd><p>This procedure, when present, returns the position in the byte stream of the next end of file, without changing the current position.</p></dd><dt><code>(<var>close</var> </code><code>)</code></dt><dd><p>This procedure marks the reader as closed, performs any necessary cleanup, and releases the resources associated with the reader.  Further operations on the reader may signal an error.</p></dd></dl></dd><dt><code>(reader-id </code><var>reader</var><code>)</code></dt><dd><p>This returns the value of the <var>id</var> field of the argument reader.</p></dd><dt><code>(reader-descriptor </code><var>reader</var><code>)</code></dt><dd><p>This returns the value of the <var>descriptor</var> field of the argument reader.</p></dd><dt><code>(reader-chunk-size </code><var>reader</var><code>)</code></dt><dd><p>This returns the value of the <var>chunk-size</var> field of the argument reader.</p></dd><dt><code>(reader-read-bytes! </code><var>reader</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p>This calls the <var>read-bytes!</var> procedure of <var>reader</var> with the remaining arguments.</p></dd><dt><code>(reader-available-bytes </code><var>reader</var><code>)</code></dt><dd><p>This calls the <var>available-bytes</var> procedure of <var>reader</var>.</p></dd><dt><code>(reader-has-get-position? </code><var>reader</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>reader</var> has a <var>get-position</var> procedure, and <code>#f</code> otherwise.</p></dd><dt><code>(reader-get-position </code><var>reader</var><code>)</code></dt><dd><p>This calls the <var>get-position</var> procedure of <var>reader</var>, if present.  It is an error to call this procedure if <var>reader</var> does not have a <var>get-position</var> procedure.</p></dd><dt><code>(reader-has-set-position!? </code><var>reader</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>reader</var> has a <var>set-position!</var> procedure, and <code>#f</code> otherwise.</p></dd><dt><code>(reader-set-position! </code><var>reader</var> <var>pos</var><code>)</code></dt><dd><p>This calls the <var>set-position!</var> procedure of <var>reader</var> with the <var>pos</var> argument, if present.  It is an error to call this procedure if <var>reader</var> does not have a <var>set-position!</var> procedure.</p></dd><dt><code>(reader-has-end-position? </code><var>reader</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>reader</var> has a <var>end-position</var> procedure, and <code>#f</code> otherwise.</p></dd><dt><code>(reader-end-position </code><var>reader</var><code>)</code></dt><dd><p>This calls the <var>end-position</var> procedure of <var>reader</var>, if present.  It is an error to call this procedure if <var>reader</var> does not have a <var>end-position</var> procedure.</p></dd><dt><code>(open-byte-vector-reader </code><var>bytes</var><code>)</code></dt><dd><p>This returns a reader that uses <var>bytes</var>, a byte vector, as its contents.  This reader has <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations.</p></dd><dt><code>(open-file-reader </code><var>filename</var><code>)</code></dt><dd><p>This returns a reader connected to the file named by <var>filename</var>.This reader may or may not have <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations.</p></dd><dt><code>(standard-input-reader </code><code>)</code></dt><dd><p>This returns a reader connected to the standard input.  The meaning of  &quot;standard input&quot; is implementation-dependent.</p></dd></dl><h4>Writers</h4><p>A writer object typically stands for a file or device descriptor, but can also represent the sink for the output of some algorithm, such as in the case of string writers.</p><dl><dt><code>(make-simple-writer </code><var>id</var> <var>descriptor</var> <var>chunk-size</var> <var>write-bytes!</var> <var>get-position</var> <var>set-position!</var> <var>end-position</var> <var>close</var><code>)</code></dt><dd><p>Returns a writer object. <var>Id</var> is a string naming the writer, provided for informational purposes only.  For a file, this will be a string representation of the file name.  <var>Descriptor</var> is supposed to be the low-level object connected to the writer, such as the OS-level file descriptor.</p><p><var>Chunk-size</var> must be a positive exact integer,  and is the recommended efficient size of the write operations on this writer.  This is typically the block size of the buffers of the operating system.  Note that this is just a recommendation --- calls to the <var>write-bytes!</var>procedure (see below) will not necessarily use it.  A value of 1 represents a recommendation to use unbuffered writes.</p><p>The remaining arguments are procedures --- <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> may be omitted, in which case the corresponding arguments must be <code>#f</code>.</p><dl><dt><code>(<var>write-bytes!</var> </code><var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers.  This writes up to <var>count</var> bytes in byte-vector <var>bytes</var> starting at index <var>start</var>.  Before it does this, it will block until it can write at least one byte.  It returns the number of bytes actually written as a positive exact integer.</p></dd><dt><code>(<var>get-position</var> </code><code>)</code></dt><dd><p>This procedure, when present, returns the current position in the byte stream as an exact integer counting the number of bytes since the beginning of the stream.</p></dd><dt><code>(<var>set-position!</var> </code><var>pos</var><code>)</code></dt><dd><p>This procedure, when present, moves to position <var>pos</var> (which must be a non-negative exact integer) in the stream.</p></dd><dt><code>(<var>end-position</var> </code><code>)</code></dt><dd><p>This procedure, when present, returns the position in the byte stream of the next end of file, without changing the current position.</p></dd><dt><code>(<var>close</var> </code><code>)</code></dt><dd><p>This procedure marks the writer as closed, performs any necessary cleanup, and releases the resources associated with the writer.  Further operations on the writer may signal an error.</p></dd></dl></dd><dt><code>(writer-id </code><var>writer</var><code>)</code></dt><dd><p>This returns the value of the <var>id</var> field of the argument writer.</p></dd><dt><code>(writer-descriptor </code><var>writer</var><code>)</code></dt><dd><p>This returns the value of the <var>descriptor</var> field of the argument writer.</p></dd><dt><code>(writer-chunk-size </code><var>writer</var><code>)</code></dt><dd><p>This returns the value of the <var>chunk-size</var> field of the argument writer.</p></dd><dt><code>(writer-write-bytes! </code><var>writer</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p>This calls the <var>write-bytes!</var> procedure of <var>writer</var> with the remaining arguments.</p></dd><dt><code>(writer-has-get-position? </code><var>writer</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>writer</var> has a <var>get-position</var> procedure, and <code>#f</code> otherwise.</p></dd><dt><code>(writer-get-position </code><var>writer</var><code>)</code></dt><dd><p>This calls the <var>get-position</var> procedure of <var>writer</var>, if present.  It is an error to call this procedure if <var>writer</var> does not have a <var>get-position</var> procedure.</p></dd><dt><code>(writer-has-set-position!? </code><var>writer</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>writer</var> has a <var>set-position!</var> procedure, and <code>#f</code> otherwise.</p></dd><dt><code>(writer-set-position! </code><var>writer</var> <var>pos</var><code>)</code></dt><dd><p>This calls the <var>set-position!</var> procedure of <var>writer</var> with the <var>pos</var> argument, if present.  It is an error to call this procedure if <var>writer</var> does not have a <var>set-position!</var> procedure.</p></dd><dt><code>(writer-has-end-position? </code><var>writer</var><code>)</code></dt><dd><p>This returns <code>#t</code> if <var>writer</var> has a <var>end-position</var> procedure, and <code>#f</code> otherwise.</p></dd><dt><code>(writer-end-position </code><var>writer</var><code>)</code></dt><dd><p>This calls the <var>end-position</var> procedure of <var>writer</var>, if present.  It is an error to call this procedure if <var>writer</var> does not have a <var>end-position</var> procedure.</p></dd><dt><code>(open-byte-vector-writer </code><code>)</code></dt><dd><p>This returns a writer that can yield everything written to it as a byte vector.  This writer has <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations.</p></dd><dt><code>(writer-byte-vector </code><var>writer</var><code>)</code></dt><dd><p>The <var>writer</var> argument must be a byte-vector writer returned by <code>open-byte-vector-writer</code>.  This procedure returns a newly allocated byte vector containing the data written to <var>writer</var> in sequence.  Doing this in no way invalidates the writer or change its store.</p></dd><dt><code>(open-file-writer </code><var>filename</var><code>)</code></dt><dd><p>This returns a writer connected to the file named by <var>filename</var>.The named file is created if it does not exist already, and truncated to zero length otherwise.  This writer may or may not have <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations.  </p></dd><dt><code>(open-file-writer/append </code><var>filename</var><code>)</code></dt><dd><p>This returns a writer connected to the file named by <var>filename</var>.The named file is created if it does not exist already.  If it does exist, this sets the current position to the end of the file.  This writer may or may not have <var>get-position</var>, <var>set-position!</var>, and <var>end-position</var> operations.</p></dd><dt><code>(standard-output-writer </code><code>)</code></dt><dd><p>This returns a writer connected to the standard output.  The meaning of  &quot;standard output&quot; is implementation-dependent.</p></dd><dt><code>(standard-error-writer </code><code>)</code></dt><dd><p>This returns a writer connected to the standard error.  The meaning of  &quot;standard error&quot; is implementation-dependent.</p></dd></dl><h3>Stream I/O</h3><p>The Stream I/O layer defines high-level I/O operations on two new datatypes: <i>input streams</i> and <i>output streams</i>.  These operations include binary and textual I/O.  Input streams are treated in lazy functional style: input from a stream <var>s</var> yields an object representing the input itself, and a new  input stream <var>s1</var>.  <var>S</var> will continue to represent exactly the same position within the input; to advance within the stream, the program needs to perform input from <var>s1</var>.  Consequently, input streams allow arbitrary lookahead, which is especially convenient for all kinds of scanning.</p><p>Output streams are more conventional, as the lazy functional style does not make sense with output.</p><p>Both input streams and output streams are either directly connected to underlying readers and writers, or are defined by translation on an underlying stream.  This makes it possible to perform trivial transformations such as CR/LF translation, but also transparent recoding on the streams.</p><p>Textual I/O always uses UTF-8 as the underlying encoding.  Other encodings can easily be supported by translating to or from UTF-8 using the translation framework.  If a decoding error occurs, the implicit decoder will skip the byte starting the character encoding, yield a ? character, and attempt to continue decoding after that initial byte.</p><p>The Stream I/O layer adds an additional condition type:</p><pre>(define-condition-type &amp;i/o-stream-error &amp;i/o-error
  i/o-stream-error?
  (stream i/o-error-stream))
</pre><p>The <code>stream</code> field has purely informational purpose.  Conditions raised in by Stream I/O procedures <em>may</em> include an <code>&amp;i/o-stream-error</code> condition, but are not required to do so.</p><h4>Input streams</h4><p>Input streams come in two flavors: either directly based on a reader, or based on another input stream via translation.  Input streams are in one of three states: active, truncated, or closed.  When initially created, a stream is active.  A program can retrieve the reader underlying an input stream---this automatically incurs disconnecting the stream from the reader, and puts the stream into the truncated state.  When explicitly closed, the reader underlying an open input stream is closed as well.  The closed state implies the truncated state.</p><p>Reading from a truncated stream is not an error; after all the existing buffers having been exhausted, the stream behaves as if an infinite sequence of end of files followed.</p><dl><dt><code>(input-stream? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is an input stream, <code>#f</code> otherwise.</p></dd><dt><code>(input-bytes </code><var>input-stream</var><code>)</code></dt><dd><p>This returns two values: a byte vector and another input stream.  If any data is available before the next end of file, this returns a freshly allocated byte vector of non-zero size containing that data.  If an end of file has been reached, the byte vector is empty, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><code>(input-byte </code><var>input-stream</var><code>)</code></dt><dd><p>This returns two values: a value and another input stream.  If a byte is available before the next end of file, this returns that byte as an exact integer.  If an end of file has been reached, the value is <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><code>(input-bytes-n </code><var>input-stream</var> <var>n</var><code>)</code></dt><dd><p><var>N</var> must be an exact, non-negative integer, specifying the number of bytes to be read.This returns two values: a byte vector and another input stream.  It tries to read <var>n</var> bytes.  If <var>n</var> or more bytes are available before the next end of file, it returns a byte vector of size <var>n</var>.  If fewer bytes are available before the next end of file, it returns a byte vector containing those bytes.  If end of file has been reached, the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><code>(input-bytes-all </code><var>input-stream</var><code>)</code></dt><dd><p>This returns two values: a byte vector and another input stream.  The byte vector contains all bytes until the next end of file.  The input stream returned points just past the end of file.  Note that this function may block indefinitely on streams connected to interactive readers.</p></dd><dt><code>(input-string </code><var>input-stream</var><code>)</code></dt><dd><p>This returns two values: a string and another input stream.  If any data is available before the next end of file, this returns a string of non-zero size containing the UTF-8 decoding of that data.  If an end of file has been reached, the string is empty, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><code>(input-char </code><var>input-stream</var><code>)</code></dt><dd><p>This returns two values: a value and another input stream.  If a char is available before the next end of file, this returns that char as an exact integer.  If an end of file has been reached, the value is <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><code>(input-string-n </code><var>input-stream</var> <var>n</var><code>)</code></dt><dd><p><var>N</var> must be an exact, non-negative integer, specifying the number of chars to be read.This returns two values: a string and another input stream.  It tries to read <var>n</var> chars.  If <var>n</var> or more chars are available before the next end of file, it returns a string of size <var>n</var>.  If fewer chars are available before the next end of file, it returns a string containing those chars.  If end of file has been reached, the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><code>(input-string-all </code><var>input-stream</var><code>)</code></dt><dd><p>This returns two values: a string and another input stream.  The string contains all text until the next end of file.  The input stream returned points just past the end of file.  Note that this function may block indefinitely on streams connected to interactive readers.</p></dd><dt><code>(input-line </code><var>input-stream</var><code>)</code></dt><dd><p>This returns two values: a value and another input stream.  If data is available before the next newline char, the value is a string that contains all text until the newline char.  The input stream returned points just past the newline char.If end of file has been reached, the value is <code>#f</code>.</p></dd><dt><code>(end-of-stream? </code><var>input-stream</var><code>)</code></dt><dd><p>This returns <var>#t</var> if the stream has reached end of file, <var>#f</var> otherwise.</p></dd><dt><code>(input-stream-position </code><var>input-stream</var><code>)</code></dt><dd><p>For reader-based input streams, this returns the reader position corresponding to the next byte read from the input stream.  This procedure raises an <code>&amp;i/o-operation-not-available-error</code> condition if the stream does not support the operation.  It is an error to apply this procedure to a truncated or closed stream, or to a translated stream.</p></dd><dt><code>(input-stream-reader+constructor </code><var>input-stream</var><code>)</code></dt><dd><p><var>Input-stream</var> must be an open input stream.  This returns two values: a reader and a procedure of one argument.  The reader is the underlying reader of the stream at the end of the chain of translations whose head is <var>input-stream</var>.  The procedure consumes a reader as its argument and returns a fresh input stream with the same chain of translations as <var>input-stream</var>.  This also disconnects the input stream from the reader and puts it into the truncated state; all other input streams based on the input stream at the end of the translation chain  (directly or indirectly) are also put into the truncated state.</p></dd><dt><code>(close-input-stream </code><var>input-stream</var><code>)</code></dt><dd><p>This closes the underlying reader if <var>input-stream</var> is still open, and marks the input stream as closed.  Applying <code>close-input-stream</code> to a closed stream has no effect.  Closing an input stream also closes all input streams that are translations  (directly or indirectly) of the input stream at the end of its own translation chain.  The return values are unspecified.</p></dd><dt><code>(open-file-input-stream </code><var>filename</var><code>)</code></dt><dd><p>This opens a reader connected to the file named by <var>filename</var> and returns an input stream connected to it.</p></dd><dt><code>(open-byte-vector-input-stream </code><var>bytes</var><code>)</code></dt><dd><p>This opens a byte-vector reader connected to <var>bytes</var> and returns an input stream connected to it.</p></dd><dt><code>(open-string-input-stream </code><var>string</var><code>)</code></dt><dd><p>This opens a byte-vector reader connected to the UTF-8 encoding of <var>string</var> and returns an input stream connected to it.</p></dd><dt><code>(open-reader-input-stream </code><var>reader</var><code>)</code></dt><dd><p>This returns an input stream connected to the reader <var>reader</var>.</p></dd><dt><code>(call-with-input-stream </code><var>input-stream</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> with <var>input-stream</var> as an argument.  If <var>proc</var> returns, then the stream is closed automatically and the values returned by <var>proc</var> are returned.  If <var>proc</var> does not return, then the stream will not be closed automatically, unless it is possible to provide that the stream will never again be used for a read operation.</p></dd><dt><code>(make-translated-input-stream </code><var>input-stream</var> <var>translate-proc</var><code>)</code></dt><dd><p>This returns a translated input stream based on <var>input-stream</var>.  <var>Translate-proc</var> must be a procedure that adheres to the following specification:</p><dl><dt><code>(<var>translate-proc</var> </code><var>input-stream</var> <var>wish</var><code>)</code></dt><dd><p><var>Input-stream</var> is the underlying input stream originally passed to <code>make-translated-input-stream</code>.  <var>Wish</var> is either <code>#f</code>, <code>#t</code>, or an exact, non-negative integer, giving a hint how much data is requested.  <code>#f</code> means a chunk of arbitrary size, suggesting that the user program called <code>input-bytes</code>, <code>#t</code> means as much as possible, suggesting that the user program  called <code>user-input-all</code>, and an integer specifies the requested  number of bytes.  Note that <var>translate-proc</var> can ignore <var>wish</var>.  The procedure must return two values, a byte vector, and another input stream, analogous to the various <code>input-...</code> procedures.  An empty byte vector denotes an end of file.  The returned input stream points just past the data returned.</p></dd></dl></dd></dl><h4>Output streams</h4><p>Output streams, like input streams, come in two flavors: either directly based on a writer, or based on another output stream via translation.  </p><p>An output stream has an associated <i>buffer mode</i> that defines when an output operation will flush the buffer associated with the output stream.  The possible buffer modes are <code>none</code> for no buffering, <code>line</code> for flushing upon newlines, and <code>block</code> for block-based buffering.</p><p>Output streams are in one of three states: active, terminated, or closed.  When initially created, a stream is active.    A program can retrieve the writer underlying an output stream---this automatically incurs disconnecting the stream from the writer, and puts the stream into the terminated state.  When explicitly closed, the writer underlying an an output stream enters the closed state.  The closed state implies the terminated state.</p><p>It is an error to perform an output operations on a terminated stream.</p><dl><dt><code>(output-stream? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is an output stream, <code>#f</code> otherwise.</p></dd><dt><code>(output-bytes </code><var>output-stream</var> <var>bytes</var><code>)</code></dt><dd><p>This writes the bytes in byte vector <var>bytes</var> to the stream.  The return values are unspecified.</p></dd><dt><code>(output-byte </code><var>output-stream</var> <var>byte</var><code>)</code></dt><dd><p>This writes the byte <var>byte</var> (which must be an exact integer in the range [0,255]) to the stream.  The return values are unspecified.</p></dd><dt><code>(output-bytes-n </code><var>output-stream</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers.  This writes the <var>count</var> bytes in byte vector <var>bytes</var> starting at index <var>start</var> to the output stream.  It is an error if the byte vector actually has size less than <var>start</var> + <var>count</var>.  The return values are unspecified.</p></dd><dt><code>(output-char </code><var>output-stream</var> <var>char</var><code>)</code></dt><dd><p>This writes the UTF-8 encoding of the char <var>char</var> to the stream.  The return values are unspecified.</p></dd><dt><code>(output-string </code><var>output-stream</var> <var>string</var><code>)</code></dt><dd><p>This writes the UTF-8 encoding of the string <var>string</var> to the stream.  The return values are unspecified.</p></dd><dt><code>(output-string-n </code><var>output-stream</var> <var>string</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p>This writes the UTF-8 encoding of the substring <code>(substring <var>string</var> (+ <var>start</var> <var>count</var>))</code> to the stream.The return values are unspecified.</p></dd><dt><code>(flush-output-stream </code><var>output-stream</var><code>)</code></dt><dd><p>This flushes any output from the buffer of <var>output-stream</var> to the underlying writer.  It is a no-op if <var>output-stream</var> is terminated.  The return values are unspecified.</p></dd><dt><code>(output-stream-position </code><var>output-stream</var><code>)</code></dt><dd><p>For writer-based output streams, this returns the writer position corresponding to the next byte read from the output stream.  This procedure raises an <code>&amp;i/o-operation-not-available-error</code> condition if the stream does not support the operation.  It is an error to apply this procedure to a terminated or closed stream, or to a translated stream.</p></dd><dt><code>(set-output-stream-position! </code><var>output-stream</var> <var>pos</var><code>)</code></dt><dd><p><var>Pos</var> must be a non-negative exact integer.  This flushes the output stream and sets the current position of underlying writer to <var>pos</var>.  This procedure raises an <code>&amp;i/o-operation-not-available-error</code> condition if the stream does not support the operation.  It is an error to apply this procedure to a terminated or closed stream, or to a translated stream.  The return values are unspecified.</p></dd><dt><code>(output-stream-writer+constructor </code><var>output-stream</var><code>)</code></dt><dd><p><var>Output-stream</var> must be an open output stream.  This returns two values: a writer and a procedure of one argument.  The writer is the underlying writer of the stream at the end of the chain of translations whose head is <var>output-stream</var>.  The procedure consumes a writer as its argument and returns a fresh output stream with the same chain of translations as <var>output-stream</var>, where each translation is in the same state as in the chain.  This also disconnects the output stream from the writer and puts it into the terminated state; all other output streams based on the output stream at the end of the translation chain  (directly or indirectly) are also put into the truncated state.</p></dd><dt><code>(close-output-stream </code><var>output-stream</var><code>)</code></dt><dd><p>This closes the underlying writer if <var>output-stream</var> is still open, and marks the output stream as closed.  Applying <code>close-output-stream</code> to a closed stream has no effect.  Closing an output stream also closes all output streams that are translations  (directly or indirectly) of the output stream at the end of its own translation chain.  The return values are unspecified.</p></dd><dt><code>(buffer-mode </code><var>name</var><code>)</code> (syntax)</dt><dd><p><var>Name</var> must be one of the identifiers <code>none</code>, <code>line</code>, and <code>block</code>.  This returns a buffer-mode object denoting the associated buffer mode.  There is only one such object for each mode, so a program can compare them using <code>eq?</code>.</p></dd><dt><code>(buffer-mode? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is a buffer-mode object, <code>#f</code> otherwise.</p></dd><dt><code>(output-stream-buffer-mode </code><var>output-stream</var><code>)</code></dt><dd><p>This returns the buffer-mode object of <var>output-stream</var>.</p></dd><dt><code>(set-output-stream-buffer-mode! </code><var>output-stream</var> <var>buffer-mode</var><code>)</code></dt><dd><p>If the current buffer mode of <var>output-stream</var> is something other than <code>none</code> and <var>buffer-mode</var> is the <code>none</code> buffer-mode object, this will first flush the output stream.  Then, it sets the buffer-mode object associated with <var>output-stream</var> to <var>buffer-mode</var>.  The return values are unspecified.</p></dd><dt><code>(open-file-output-stream </code><var>filename</var><code>)</code></dt><dd><p>This opens a writer connected to the file named by <var>filename</var> via <code>open-file-writer</code> and returns an output stream with unspecified buffering mode connected to it.</p></dd><dt><code>(open-file-output-stream/append </code><var>filename</var><code>)</code></dt><dd><p>This opens a writer connected to the file named by <var>filename</var> via <code>open-file-writer/append</code> and returns an output stream with unspecified buffering mode connected to it.</p></dd><dt><code>(call-with-byte-vector-output-stream </code><var>proc</var><code>)</code></dt><dd><p><var>Proc</var> is a procedure accepting one argument.  This creates an unbuffered output stream connected to a byte-vector writer, and calls <var>proc</var> with that output stream as an argument.  The call to <code>call-with-byte-vector-output-stream</code> returns the byte vector associated with the stream when <var>proc</var> returns.</p></dd><dt><code>(call-with-string-output-stream </code><var>proc</var><code>)</code></dt><dd><p><var>Proc</var> is a procedure accepting one argument.  This creates an unbuffered output stream connected to a byte-vector writer, and calls <var>proc</var> with that output stream as an argument.  The call to <code>call-with-string-output-stream</code> returns the UTF-8 decoding of the byte vector associated with the stream when <var>proc</var> returns.</p></dd><dt><code>(call-with-output-stream </code><var>output-stream</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> with <var>output-stream</var> as an argument.  If <var>proc</var> returns, then the stream is closed automatically and the values returned by <var>proc</var> are returned.  If <var>proc</var> does not return, then the stream will not be closed automatically, unless it is possible to provide that the stream will never again be used for a write operation.</p></dd><dt><code>(make-translated-output-stream </code><var>output-stream</var> <var>translate-proc</var> <var>state</var><code>)</code></dt><dd><p>This returns a translated output stream based on <var>output-stream</var>.  The translation can thread an arbitrary state from one output operation to the next; the initial state is given by <var>state</var>.  <var>Translate-proc</var> must be a procedure that adheres to the following specification:</p><dl><dt><code>(<var>translate-proc</var> </code><var>output-stream</var> <var>state</var> <var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p>This is expected to write the output data in <var>bytes</var> to <var>output-stream</var>, which is the output stream passed into <code>make-translated-output-stream</code>.  <var>State</var> is the translation state associated with the output stream.<var>Bytes</var> is the data to be written: it is either a byte vector or a byte represented an an exact integer.  If <var>bytes</var> is a byte vector, <var>start</var> is an exact integer representing the starting index of the data to be written within <var>bytes</var>.  <var>Count</var> is the number of data bytes within <var>bytes</var> to be written.</p><p>The procedure must return a new state object, which will be passed to the next call to <var>translate-proc</var>.  It is recommended that <var>translate-proc</var> not modify <var>state</var>itself, but rather generate a new state object if necessary.  Otherwise, the constructor procedure by <code>output-stream-writer+constructor</code> may not operate correctly.</p></dd></dl></dd></dl><h3>Imperative I/O</h3><p>The Imperative I/O layer provides buffered I/O using mutable, redirectable so-called <i>ports</i>.  A port is essentially just a reference cell to a stream.  The port layer is very similar, but not identical, to the R5RS I/O system.</p><p>The Imperative I/O layer introduces one condition type of its own.</p><dl><dt><p><pre>(define-condition-type &amp;i/o-port-error &amp;i/o-error
  i/o-port-error?
  (port i/o-error-port))
</pre></p></dt><dd><p>This condition type allows specifying with what particular port an I/O error is associated.  The <code>port</code> field has purely informational purpose.  Conditions raised in by Imperative I/O procedures <em>may</em> include an <code>&amp;i/o-port-error</code> condition, but are not required to do so.</p></dd></dl><h4>Input ports</h4><dl><dt><code>(input-port? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is an input port, <code>#f</code> otherwise.</p></dd><dt><code>(input-port-stream </code><var>input-port</var><code>)</code></dt><dd><p>This returns the input stream underlying <var>input-port</var>.</p></dd><dt><code>(set-input-port-stream! </code><var>input-port</var> <var>input-stream</var><code>)</code></dt><dd><p>This sets the input stream underlying <var>input-port</var> to <var>input-stream</var>.</p></dd><dt><code>(read-bytes </code><code>)</code></dt><dt><code>(read-bytes </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-bytes</code> on the underlying input stream, updates the underlying input stream to the second return value, and returns <code>input-bytes</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(read-byte </code><code>)</code></dt><dt><code>(read-byte </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-byte</code> on the underlying input stream, updates the underlying input stream to the second return value, and returns <code>input-byte</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(read-bytes-n </code><var>n</var><code>)</code></dt><dt><code>(read-bytes-n </code><var>n</var> <var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-bytes-n</code> on the underlying input stream, updates the underlying input stream to the second return value, and returns <code>input-bytes-n</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(read-bytes-all </code><code>)</code></dt><dt><code>(read-bytes-all </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-bytes-all</code> on the underlying input stream, updates the underlying input stream to the second return value, and returns <code>input-bytes-all</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(read-string </code><code>)</code></dt><dt><code>(read-string </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-string</code> on the underlying input stream, updates the underlying input stream to the second return value, and returns <code>input-string</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(read-char </code><code>)</code></dt><dt><code>(read-char </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-char</code> on the underlying input stream, updates the underlying input stream to the second return value, and returns <code>input-char</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(read-string-n </code><var>n</var><code>)</code></dt><dt><code>(read-string-n </code><var>n</var> <var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-string-n</code> on the underlying input stream, updates the underlying input stream to the second return value, and returns <code>input-string-n</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(read-string-all </code><code>)</code></dt><dt><code>(read-string-all </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-string-n</code> on the underlying input stream, updates the underlying input stream to the second return value, and returns <code>input-string-all</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(peek-byte </code><code>)</code></dt><dt><code>(peek-byte </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-byte</code> on the underlying input stream, but does not update the underlying input stream.  It returns <code>input-byte</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(peek-char </code><var>input-port</var><code>)</code></dt><dt><code>(peek-char </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-char</code> on the underlying input stream, but does not update the underlying input stream.  It returns <code>input-char</code>'s first return value.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(eof? </code><code>)</code></dt><dt><code>(eof? </code><var>input-port</var><code>)</code></dt><dd><p>This returns the result of calling <code>end-of-stream?</code> on the input stream underlying <var>input-port</var>.  <var>Input-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-input-port)</code>.</p></dd><dt><code>(input-port-position </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>input-stream-position</code> on the underlying input stream and returns the result.</p></dd><dt><code>(close-input-port </code><var>input-port</var><code>)</code></dt><dd><p>This calls <code>close-input-stream</code> on the stream underlying <var>input-port</var>.</p></dd><dt><code>(open-input-file </code><var>filename</var><code>)</code></dt><dd><p>This returns an input port for the named file, associated with a stream created by <code>open-file-input-stream</code>.</p></dd><dt><code>(open-input-byte-vector </code><var>bytes</var><code>)</code></dt><dd><p>This returns an input port, associated with a byte-vector stream on the byte vector <var>bytes</var> created by <code>open-byte-vector-input-stream</code>.</p></dd><dt><code>(open-input-string </code><var>string</var><code>)</code></dt><dd><p>This returns an input port, associated with a byte-vector stream on the UTF-8 encoding of string <var>string</var> created by <code>open-string-input-stream</code>.</p></dd><dt><code>(call-with-input-port </code><var>input-port</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> with <var>input-port</var> as an argument.  If <var>proc</var> returns, then the port is closed automatically and the values returned by <var>proc</var> are returned.  If <var>proc</var> does not return, then the port will not be closed automatically, unless it is possible to provide that the port will never again be used for a read operation.</p></dd><dt><code>(call-with-current-input-port </code><var>input-port</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> must with no arguments---during the extent of the call to <code>call-with-current-input-port</code>, the value of <code>(current-input-port)</code> is changed to return <var>input-port</var>.  When control leaves the extent of the call, the previous return value is restored.  The call to <code>call-with-current-input-port</code> returns whatever <var>proc</var> returns.</p></dd><dt><code>(current-input-port </code><code>)</code></dt><dd><p>Returns the current default input port.</p></dd></dl><h4>Output ports</h4><dl><dt><code>(output-port? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is an output port, <code>#f</code> otherwise.</p></dd><dt><code>(output-port-stream </code><var>output-port</var><code>)</code></dt><dd><p>This returns the output stream underlying <var>output-port</var>.</p></dd><dt><code>(set-output-port-stream! </code><var>output-port</var> <var>output-stream</var><code>)</code></dt><dd><p>This sets the output stream underlying <var>output-port</var> to <var>output-stream</var>.</p></dd><dt><code>(display-bytes </code><var>bytes</var><code>)</code></dt><dt><code>(display-bytes </code><var>bytes</var> <var>output-port</var><code>)</code></dt><dd><p>This calls <code>output-bytes</code> on the underlying output stream and <var>bytes</var>.  The return values are unspecified.  <var>Output-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-output-port)</code>.</p></dd><dt><code>(display-byte </code><var>byte</var><code>)</code></dt><dt><code>(display-byte </code><var>byte</var> <var>output-port</var><code>)</code></dt><dd><p>This calls <code>output-byte</code> on the underlying output stream and <var>byte</var>.  The return values are unspecified.  <var>Output-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-output-port)</code>.</p></dd><dt><code>(display-bytes-n </code><var>bytes</var> <var>start</var> <var>count</var><code>)</code></dt><dt><code>(display-bytes-n </code><var>bytes</var> <var>start</var> <var>count</var> <var>output-port</var><code>)</code></dt><dd><p>This calls <code>output-bytes-n</code> on the underlying output stream and <var>bytes</var>, <code>start</code> and <code>count</code>.  The return values are unspecified.  <var>Output-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-output-port)</code>.</p></dd><dt><code>(display-string </code><var>string</var><code>)</code></dt><dt><code>(display-string </code><var>string</var> <var>output-port</var><code>)</code></dt><dd><p>This calls <code>output-string</code> on the underlying output stream and <var>string</var>.  The return values are unspecified.  <var>Output-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-output-port)</code>.</p></dd><dt><code>(display-char </code><var>char</var><code>)</code></dt><dt><code>(display-char </code><var>char</var> <var>output-port</var><code>)</code></dt><dd><p>This calls <code>output-char</code> on the underlying output stream and <var>char</var>.  The return values are unspecified.  <var>Output-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-output-port)</code>.</p></dd><dt><code>(display-string-n </code><var>string</var> <var>start</var> <var>count</var><code>)</code></dt><dt><code>(display-string-n </code><var>string</var> <var>start</var> <var>count</var> <var>output-port</var><code>)</code></dt><dd><p>This calls <code>output-string-n</code> on the underlying output stream and <var>string</var>, <code>start</code> and <code>count</code>.  The return values are unspecified.  <var>Output-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-output-port)</code>.</p></dd><dt><code>(newline </code><code>)</code></dt><dt><code>(newline </code><var>output-port</var><code>)</code></dt><dd><p>This is equivalent to <code>(display-char #\newline <var>output-port</var>)</code>.  The return values are unspecified.  <var>Output-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-output-port)</code>.</p></dd><dt><code>(flush-output-port </code><code>)</code></dt><dt><code>(flush-output-port </code><var>output-port</var><code>)</code></dt><dd><p>This calls <code>flush-output-stream</code> on the underlying output stream.  The return values are unspecified.  <var>Output-port</var> may be omitted, in which case it defaults to the value returned by <code>(current-output-port)</code>.</p></dd><dt><code>(output-port-position </code><var>output-port</var><code>)</code></dt><dd><p>This calls <code>output-stream-position</code> on the underlying output stream and returns the result.</p></dd><dt><code>(set-output-port-position! </code><var>output-port</var> <var>pos</var><code>)</code></dt><dd><p>This calls <code>set-output-stream-position!</code> on the underlying output stream with <var>pos</var> and returns whatever it returns.</p></dd><dt><code>(close-output-port </code><var>output-port</var><code>)</code></dt><dd><p>This calls <code>close-output-stream</code> on the stream underlying <var>output-port</var>.</p></dd><dt><code>(open-output-file </code><var>filename</var><code>)</code></dt><dd><p>This returns an output port for the named file, associated with a stream created by <code>open-file-output-stream</code>.</p></dd><dt><code>(open-output-file/append </code><var>filename</var><code>)</code></dt><dd><p>This returns an output port for the named file, associated with a stream created by <code>open-file-output-stream/append</code>.</p></dd><dt><code>(call-with-output-byte-vector </code><var>proc</var><code>)</code></dt><dd><p><var>Proc</var> is a procedure accepting one argument.  This creates an output port on an unbuffered output stream connected to a byte-vector writer, and calls <var>proc</var> with that output port as an argument.  The call to <code>call-with-byte-vector-output-port</code> returns the byte vector associated with the stream when <var>proc</var> returns.</p></dd><dt><code>(call-with-output-string </code><var>proc</var><code>)</code></dt><dd><p><var>Proc</var> is a procedure accepting one argument.  This creates an output port on an unbuffered output stream connected to a byte-vector writer, and calls <var>proc</var> with that port as an argument.  The call to <code>call-with-string-output-stream</code> returns the UTF-8 decoding of the byte vector associated with the stream when <var>proc</var> returns.</p></dd><dt><code>(call-with-output-port </code><var>output-port</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> with <var>output-port</var> as an argument.  If <var>proc</var> returns, then the port is closed automatically and the values returned by <var>proc</var> are returned.  If <var>proc</var> does not return, then the port will not be closed automatically, unless it is possible to provide that the port will never again be used for a write operation.</p></dd><dt><code>(call-with-current-output-port </code><var>output-port</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> must with no arguments---during the extent of the call to <code>call-with-current-output-port</code>, the value of <code>(current-output-port)</code> is changed to return <var>output-port</var>.  When control leaves the extent of the call, the previous return value is restored.  The call to <code>call-with-current-output-port</code> returns whatever <var>proc</var> returns.</p></dd><dt><code>(current-output-port </code><code>)</code></dt><dd><p>Returns the current default output port.</p></dd></dl>

<h1>Design rationale</h1>
<h3>Encoding</h3><p>Many I/O system implementations allow associating an encoding with a port, allowing the direct use of several different encodings with ports.  The problem with this approach is that the encoding/decoding defines a mapping from binary data to text or vice versa.  Because of this asymmetry, such mappings do not compose.  The result is usually complications and restrictions in the I/O API, such as the inability to mix text or binary data, or the inability to change encoding mid-stream.</p><p>This SRFI avoids this problem by specifying that textual I/O always uses UTF-8.  This means that, if the target or source of an I/O stream is to use a different encoding, a translated stream needs to be used, for which this SRFI offers the required facilities.  This means that text decoders or encoders are expressed as binary-to-binary mappings, and as such compose.</p><p>It would easily be possible to construct a library of text recoders for use with this SRFI, possibly connected to some notion of locale.  This would properly be the subject of another SRFI, however.</p><h3><code>display-char</code> vs <code>write-char</code></h3><p>R5RS calls the procedure for writing a character to an output port <code>write-char</code>.  This is inconsistent with the behavior of <code>write</code>, which outputs characters using the <code>\#</code> notation.  Instead, it is consistent with the behavior of <code>display</code>, which is why the procedure is called <code>display-char</code> here, and why the other port output procedures have names starting with <code>display-</code>.</p><p>Historically, it seems that the <a href="http://zurich.ai.mit.edu/pipermail/rrrs-authors/1985-March.txt">original proposal for the I/O subsystem in RnRS</a> indeed called the procedure <code>display-char</code>.  I do not know why it was renamed---probably for compatibility with Common Lisp, which also has <code>write-char</code>.</p><h3><code>char-ready?</code></h3><p>This SRFI intentionally does not provide <code>char-ready?</code>, which is part of R5RS.  The original intention of the procedure seems to have been to interface with something like Unix <code>select(2)</code>.  With multi-byte encodings such as UTF-8, this is no longer sufficient: the procedure would really have to look at the actual input data in order to determine whether a complete character is actually present.  This makes realistic implementations of <code>char-ready?</code> inconsistent with the user's expectations.  A procedure <code>byte-ready?</code> would be more consistent.  On the other hand, such a procedure is rarely useful in real-world programs, and complicates all layers of the I/O system, as readers would have to provide an additional member procedure to enable its implementation.  Moreover, a <code>select(2)</code>-like implementation is not possible on all plattforms and all types of ports.  Consequently, <code>char-ready?</code> and <code>byte-ready?</code>are not part of this SRFI.</p><h3><code>display</code></h3><p>This SRFI does not provide <code>display</code>, which is part of R5RS.  <code>Display</code> is woefully underspecified, and mostly used to output strings.  For this purpose, this SRFI offers <code>display-string</code>.</p><h3>No distinct end of file object</h3><p>In R5RS, the distinct type of end of file objects is primarily for the benefit of <code>read</code>, where end of file must be denoted by an object that <code>read</code> cannot normally return as a result of parsing the input.  However, it does not seem necessary to drag in the complications of this separate object into a pure I/O SRFI, where <code>#f</code> or the empty byte vector or the empty string is perfectly adequate to represent end of file.</p><p>It is debatable whether not all input procedures should denote end of file by <code>#f</code>.  The present arrangement is the way it is primarily because it is that way in the SML Basis Library.</p>

<h1>Reference Implementation</h1>
<p><a href="comprehensive-io-reference.tar.gz">Here</a> is a tarball containing a reference implementation of this SRFI.  It only runs on a version of Scheme 48 that has not been released at the time of writing in this SRFI.</p><p>However, its actual dependencies on Scheme 48 idiosyncracies are few.  Chief are its use of the module system, which is easily replaced by another, and the implementation of Unicode.  To implement primitive readers and writers on files, the code only relies on suitable library procedures to open the files, and <code>read-byte</code> and <code>write-byte</code> procedures to read or write single bytes from a (R5RS) port, as well as a <code>force-output</code> procedure to flush a port.</p><p>The reference implementation has not been highly tuned, but I have spent a modest amount of time making the code deal with buffers in an economic buffer.  Because of this, the code is more complicated than it needs to be, but hopefully also more usable as a basis for implementing this SRFI in actual Scheme systems.</p>

<h1>Examples</h1>
<p>Many examples are adapted from <a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a> edited by Emden R. Gansner and John H. Reppy.  Cambrige University Press, 2004.</p><p>The code makes liberal use of SRFIs <a href="http://srfi.schemers.org/srfi-1/">1</a> (List Library), <a href="http://srfi.schemers.org/srfi-11/">11</a> (Syntax for receiving multiple values), <a href="http://srfi.schemers.org/srfi-26/">26</a> (Notation for Specializing Parameters without Currying).</p><p>The tarball with the reference implementation contains these examples along with test cases for them.</p><p>This customized reader reads from a list of byte vectors.  A null byte vector yields EOF. Procedures for defining streams based on such readers follow.</p><pre>(define (open-byte-vectors-reader bs)
  (let* ((pos 0))
                   
    (make-simple-reader
     &quot;&lt;byte vectors&gt;&quot;
     bs
     5                                  ; for debugging
     (lambda (byte-vector start count)
       (cond
        ((null? bs)
         0)
        (else
         (let* ((b (car bs))
                (size (byte-vector-length b))
                (real-count (min count (- size pos))))
           (byte-vector-copy! byte-vector start
                              b pos (+ pos real-count))
           (set! pos (+ pos real-count))
           (if (= pos size)
               (begin
                 (set! bs (cdr bs))
                 (set! pos 0)))
           real-count))))
     ;; rough approximation ...
     (lambda ()
       (if (null? bs)
           0
           (- (byte-vector-length (car bs)) pos)))
     #f #f #f                           ; semantics would be unclear
     (lambda ()
       (set! bs #f)))))                 ; for GC

(define (open-strings-reader strings)
  (open-byte-vectors-reader (map string-&gt;utf-8 strings)))

(define (open-byte-vectors-input-stream byte-vectors)
  (open-reader-input-stream (open-byte-vectors-reader byte-vectors)))

(define (open-strings-input-stream strings)
  (open-reader-input-stream (open-byte-vectors-reader (map string-&gt;utf-8 strings))))
</pre><p>Create a string via a string output port:</p><pre>(define three-lines-string
  (call-with-output-string
   (lambda (port)
     (display-string &quot;foo&quot; port) (newline port)
     (display-string &quot;bar&quot; port) (newline port)
     (display-string &quot;baz&quot; port) (newline port))))
</pre><p>Note that, for input streams, the successive streams need to be threaded through the program:</p><pre>(define (input-two-lines s)
  (let*-values (((line-1 s-2) (input-line s))
                ((line-2 _)   (input-line s-2)))
    (values line-1 line-2)))
</pre><p>There may be life after end of file; hence, the following is not guaranteed to return true:</p><pre>(define (at-end?/broken s)
  (let ((z (end-of-stream? s)))
    (let-values (((a s-2) (input-bytes s)))
      (let ((x (end-of-stream? s-2)))
        (equal? z x)))))
</pre><p>... but this is:</p><pre>(define (at-end? s)
  (let ((z (end-of-stream? s)))
    (let-values (((a s-2) (input-bytes s)))
      (let ((x (end-of-stream? s)))
        (equal? z x)))))
</pre><p>Catch an I/O exception:</p><pre>(define (open-it filename)
  (guard
   (condition
    ((i/o-error? condition)
     (if (message-condition? condition)
         (begin
           (display-string (condition-message condition)
                           (current-error-port))
           (newline (current-error-port))))
     #f))
   (open-file-input-stream filename)))
</pre><p>Read a file directly:</p><pre>(define (get-contents filename)
  (call-with-input-port (open-input-file filename)
    read-bytes-all))
</pre><p>Read a file byte-by-byte:</p><pre>(define (get-contents-2 filename)
  (call-with-input-port (open-input-file filename)
    (lambda (port)
      (let loop ((accum '()))
        (let ((thing (read-byte port)))
          (if (not thing)
              (list-&gt;byte-vector (reverse accum))
              (loop (cons thing accum))))))))

(define (list-&gt;byte-vector l)
  (let ((bytes (make-byte-vector (length l) 0)))
    (let loop ((i 0) (l l))
      (if (null? l)
          bytes
          (begin
            (byte-vector-set! bytes i (car l))
            (loop (+ 1 i) (cdr l)))))))
</pre><p>Read file chunk-by-chunk:</p><pre>(define (get-contents-3 filename)
  (call-with-input-port (open-input-file filename)
    (lambda (port)
      (let loop ((accum '()))
        (let ((bytes (read-bytes port)))
          (if (zero? (byte-vector-length bytes))
              (concatenate-byte-vectors (reverse accum))
              (loop (cons bytes accum))))))))

(define (concatenate-byte-vectors list)
  (let* ((size (fold + 0 (map byte-vector-length list)))
         (result (make-byte-vector size 0)))
    (let loop ((index 0)
               (byte-vectors list))
      (if (null? byte-vectors)
          result
          (let* ((b (car byte-vectors))
                 (size (byte-vector-length b)))
            (byte-vector-copy! result index
                               b 0 size)
            (loop (+ index size)
                  (cdr byte-vectors)))))))
</pre><p>Note that imperatively changing the stream of <code>(current-input-port)</code>is not a good idea, as it may be shared among several threads:</p><pre>(define (redirect-in g filename)
  (call-with-input-port (open-input-file filename)
    (cut call-with-current-input-port &lt;&gt; g)))
</pre><p>Read a file using Stream I/O:</p><pre>(define (get-contents/stream filename)
  (call-with-input-stream (open-file-input-stream filename)
    (lambda (stream)
      (let-values (((bytes _) (input-bytes-all stream)))
        bytes))))
</pre><p>Read a file byte by byte:</p><pre>(define (get-contents/stream-2 filename)
  (call-with-input-stream (open-file-input-stream filename)
    (lambda (stream)
      (let loop ((accum '()) (stream stream))
        (let-values (((byte stream) (input-byte stream)))
          (if (not byte)
              (list-&gt;byte-vector (reverse accum))
              (loop (cons byte accum) stream)))))))
</pre><p>Read a file chunk-by-chunk:</p><pre>(define (get-contents/stream-3 filename)
  (call-with-input-stream (open-file-input-stream filename)
    (lambda (stream)
      (let loop ((accum '()) (stream stream))
        (let-values (((chunk stream) (input-bytes stream)))
          (if (zero? (byte-vector-length chunk))
              (concatenate-byte-vectors (reverse accum))
              (loop (cons chunk accum) stream)))))))
</pre><p>Drop a word at the beginning of a stream selectively:</p><pre>(define (eat-thousand stream)
  (let-values (((text new-stream)
                (input-string-n stream (string-length &quot;thousand&quot;))))
    (if (string=? text &quot;thousand&quot;)
        new-stream
        stream)))
</pre><p>Skip whitespace at the beginning of a stream:</p><pre>(define (skip-whitespace stream)
  (let-values (((thing new-stream)
                (input-char stream)))
    (cond
     ((not thing) stream)
     ((char-whitespace? thing)
      (skip-whitespace new-stream))
     (else stream))))
</pre><p>Reading a line could be implemented by scanning forward, then reading a chunk from the original position:</p><pre>(define (my-input-line stream)
  (let count ((n 0) (g stream))
    (let-values (((thing g*) (input-char g)))
      (cond
       ((not thing)
        (if (zero? n)
            (values #f g*)
            (input-string-n stream n)))
       ((char=? #\newline thing)
        (let*-values (((line _) (input-string-n stream n)))
          (values line g*)))
       (else
        (count (+ 1 n) g*))))))
</pre><p>Write some text to a file:</p><pre>(define (hello myfile)
  (call-with-output-stream (open-file-output-stream myfile)
    (lambda (stream)
      (output-string stream &quot;Hello, &quot;)
      (output-string stream &quot;world!&quot;)
      (output-char stream #\newline))))
</pre><p>Extract the reader from a stream, read a byte from it, and then reconstruct a stream from it:</p><pre>(define (after-first filename)
  (let ((stream (open-file-input-stream filename)))
    (call-with-values
        (lambda () (input-stream-reader+constructor stream))
      (lambda (reader construct)
        (let ((b (make-byte-vector 1 0)))
          (reader-read-bytes! reader b 0 1)
          (call-with-input-stream (construct (open-reader-input-stream reader))
            (lambda (stream-2)
              (let-values (((contents _) (input-string-all stream-2)))
                contents))))))))
</pre><p>Extract the reader from a stream, set position, and then reconstruct a stream from it:</p><pre>(define (after-n stream n)
  (call-with-values
      (lambda () (input-stream-reader+constructor stream))
    (lambda (reader construct)
      (reader-set-position! reader n)
       (call-with-input-stream (construct (open-reader-input-stream reader))
         (lambda (stream-2)
           (let-values (((contents _) (input-string-all stream-2)))
             contents))))))
</pre><p>Translate CR/LF to LF on input:</p><pre>(define (translate-crlf-input original-input-stream wish)

  ;; state automaton

  (define (vanilla input-stream count)
    (call-with-values
        (lambda ()
          (input-byte input-stream))
      (lambda (byte input-stream)
        (cond
         ((not byte) (finish count))
         ((= 13 byte) (cr input-stream count))
         (else (vanilla input-stream (+ 1 count)))))))
            
  (define (cr input-stream count)
    (call-with-values
        (lambda ()
          (input-byte input-stream))
      (lambda (byte input-stream)
        (cond
         ((not byte) (finish (+ 1 count)))      ; CR hasn't been counted yet
         ((= 10 byte)
          (call-with-values
              (lambda ()
                (input-bytes-n original-input-stream (+ 1 count)))
            (lambda (bytes _)
              (byte-vector-set! bytes count 10)
              (values bytes input-stream))))
         (else (vanilla input-stream (+ count 1)))))))

  (define (finish count)
    (call-with-values
        (lambda ()
          (input-bytes-n original-input-stream count))
      (lambda (bytes input-stream)
        (values bytes input-stream))))    
          
  (vanilla original-input-stream 0))

(define (make-crlf-translated-input-stream input-stream)
  (make-translated-input-stream input-stream
                                translate-crlf-input))
</pre><p>Translate LF to CR/LF on output:</p><pre>(define (make-crlf-translated-output-stream output-stream)
  (make-translated-output-stream output-stream
                                 translate-crlf-output
                                 #f))

(define (unspecific)
  (if #t #t))

(define (translate-crlf-output output-stream state data start count)
  (cond
   ((byte-vector? data)
    (let ((end (+ start count)))
      (let loop ((index start))
        (cond
         ((byte-vector-index data 10 index end)
          =&gt; (lambda (lf-index)
               (output-bytes-n output-stream data index (- lf-index index))
               (output-byte output-stream 13)
               (output-byte output-stream 10)
               (loop (+ 1 lf-index))))
         (else
          (output-bytes-n output-stream data index (- end index)))))))
   ((= data 10)
    (output-byte output-stream 13)
    (output-byte output-stream 10))
   (else
    (output-byte output-byte data)))
  (unspecific))

(define (byte-vector-index byte-vector byte start end)
  (let loop ((index start))
    (cond
     ((&gt;= index end)
      #f)
     ((= byte (byte-vector-ref byte-vector index))
      index)
     (else
      (loop (+ 1 index))))))
</pre><p>Algorithmic reader producing an infinite stream of blanks:</p><pre>(define (make-infinite-blanks-reader)
  (make-simple-reader &quot;&lt;blanks, blanks, and more blanks&gt;&quot;
                      #f
                      4096
                      (lambda (bytes start count)
                        (let loop ((index 0))
                          (if (&gt;= index count)
                              index
                              (begin
                                (byte-vector-set! bytes (+ start index) 32)
                                (loop (+ 1 index))))))
                      (lambda ()
                        1000) ; some number
                      #f #f #f
                      unspecific))

(define (make-infinite-blanks-stream)
  (open-reader-input-stream (make-infinite-blanks-reader)))
</pre>

<h1>Acknowledgements</h1>

<p>Sebastian Egner provided valuable comments on a draft of this SRFI.</p><h1>References</h1><ul><li><a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a> edited by Emden R. Gansner and John H. Reppy.  Cambrige University Press, 2004.</li><li><a href="http://www.unicode.org/">The Unicode Home Page</a></li></ul></body>

<H1>Copyright</H1>
Copyright (C) Michael Sperber (2005). All Rights Reserved. 
<p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

    <hr>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">Francisco Solsona</a></address>
</body></html>
