<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content=
  "HTML Tidy for Linux/x86 (vers 1st July 2003), see www.w3.org"
  name="generator">

  <title>SRFI 44: Collections</title>
</head>

<body>

  <H1>Title</H1>

    Collections

  <H1>Author</H1>

    Scott G. Miller

    <H1>Status</H1> 

    This SRFI is currently in ``draft'' status.  To see an explanation
    of each status that a SRFI can hold, see <A
    HREF="http://srfi.schemers.org/srfi-process.html">here</A>.  It
    will remain in draft status until 2003/07/28, or as amended.

    To provide input on this SRFI, please <code><A
    HREF="mailto:srfi-44@srfi.schemers.org">mail to
    &lt;srfi-44@srfi.schemers.org&gt;</A></code>.  See <A
    HREF="../srfi-list-subscribe.html">instructions here</A> to
    subscribe to the list.  You can access previous messages via <A
    HREF="mail-archive/maillist.html">the archive of the mailing
    list</A>.


    <p><ul>
      <li>Received: 2003/04/23
      <li>Draft: 2003/04/28-2003/07/28
      <li>Revised: 2003/07/02
      <li>Revised: 2003/07/24
      <li>Revised: 2003/08/10
      <li>Revised: 2003/08/19
      <li>Revised: 2003/08/27
      <li>Revised: 2003/09/11
      <li>Revised: 2003/10/07
      <li>Revised: 2003/10/08
      <li>Revised: 2003/11/24
    </ul></p>

  <H1>Abstract</H1>

    
  <p>A Collections API which defines a common naming scheme and set
  of operations for creating, accessing, and manipulating common
  datastructures in Scheme. The API defines accessors, a common
  protocol for value access via generic and specific enumeration, 
  and functions for inter-datastructure cooperation. Finally, a concrete
  specification of a compliant set of operators for the standard
  Scheme heterogenous datastructures (lists and vectors) and for
  the homogeneous Scheme string is provided.</p>

  <H1>Table of Contents</H1>

  <blockquote>
    <a href="#issues">Issues</a><br>
    <a href="#rationale">Rationale</a><br>
    <a href="#specification">Specification</a><br>

    <blockquote>
      <a href="#chier">Collections Hierarchy</a><br>
      <a href="#storagemodel">Storage Model</a><br>
      <a href="#dispatch">Dispatch Mechanism</a><br>
      <a href="#typing">Typing</a><br>
      <a href="#attribute">Collection Attributes</a><br>

      <blockquote>
        <a href="#ordered">Ordered Collections</a><br>
        <a href="#ordered">Directional Collections</a><br>
        <a href="#mutable">Purely Mutable Collections</a><br>
        <a href="#limitedcollections">Limited Collections</a>
      </blockquote><a href="#foldingenums">Folding
      Enumerators</a><br>

      <blockquote>
        <a href="#stability">Enumeration Stability</a>
      </blockquote><a href="#equivalence">Equivalence</a><br>
      <a href="#immutablecols">Immutable Collections</a><br>
      <a href="#homogeneity">Homogeneity</a><br>
      <a href="#sizevslength">Size versus Length</a><br>
      <a href="#infcoll">Infinite Collections</a><br>
      <a href="#orderedcols">Ordered Collections</a><br>
      <a href="#valueequality">Bags, Sets, Maps and Value
      Equality</a><br>
      <a href="#sequences">Sequences</a><br>

      <blockquote>
        <a href="#flexsequences">Flexible Sequences</a>
      </blockquote><a href="#procedures">Procedures</a><br>

      <blockquote>
        <a href="#flup">Functional, Linear Update, and Purely
        Mutable Collections</a><br>
        <a href="#enumprocs">Enumeration</a><br>
        <a href="#collprocs">Collections</a><br>
        <a href="#orderedcollprocs">Ordered Collections</a><br>
        <a href="#directionalcollprocs">Directional
        Collections</a><br>
        <a href="#limitedcollprocs">Limited Collections</a><br>
        <a href="#mutablecollprocs">Purely Mutable
        Collections</a><br>
        <a href="#bagprocs">Bags</a><br>
        <a href="#setprocs">Sets</a><br>
        <a href="#sequenceprocs">Sequences</a><br>
        <a href="#flexsequenceprocs">Flexible Sequences</a><br>
        <a href="#mapprocs">Maps</a><br>
        <!--        <a href="#dictprocs">Dictionaries</a><br>-->
      </blockquote><a href="#schemecolls">Scheme
      Collections</a><br>

      <blockquote>
        <a href="#lists">Lists</a><br>
        <a href="#alists">Association List Maps</a><br>
        <a href="#vectors">Vectors</a><br>
        <a href="#strings">Strings</a>
      </blockquote>
    </blockquote><a href="#compat">Compatibility</a><br>

    <blockquote>
      <a href="#r5rsext">Extensions to R5RS</a><br>
      <a href="#othersrfis">Relation to other SRFIs</a><br>
      <a href="#impls">Relation to Scheme implementations</a>
    </blockquote><a href="#implementation">Implementation</a><br>
    <a href="#futurework">Future Work</a><br>
    <a href="#references">References</a>
  </blockquote>

  <H1><a name="issues">Issues</a></H1>

  <p>Several functions in this SRFI are required to take arbitrary
  collections or major collection subtypes as input. This requires
  that the function in question be able to determine the specific
  type of the collection and dispatch to an appropriate
  implementation.</p>

  <p>As standard Scheme lacks the ability to automatically dispatch
  on different function behaviors based on the types of arguments,
  it is difficult to devise a portable implementation of this SRFI
  which allows arbitrary future collections. It is expected that
  Scheme system implementors will take advantage of generic
  function, module system, or object-oriented features of their
  systems to implement this SRFI efficiently. At the same time it
  is hoped that a future SRFI will specify a mechanism which will
  allow a portable and efficient implementation of collections to
  exist. The reference implementation in this SRFI compromises by
  using the portable Tiny-CLOS object system as a framework for
  collection-function dispatch.</p>

  <p>It should finally be noted that this SRFI does <i>not</i>
  require that all function calls to collection supertypes remain
  capable of dynamic dispatch. If a compiler or optimizer can infer
  the types of a collection function's arguments, or a user
  provides hints to that effect, it is permitted to monomorphize
  the call. That is, to statically compile a more specific but
  semantically equivalent collection function in place.</p>

  <H1><a name="rationale">Rationale</a></H1>

  <p>The Scheme language provides two basic datastructures for
  containing any first-class value. Scheme pairs, and by extension
  lists, provide a variable sized datastructure with constant time
  extension and linear time access. Scheme vectors provide a fixed
  sized datastructure with typically constant time access. From
  these two datastructures it is possible to build up many other
  types of datastructures, including hash tables, trees, and
  sets.</p>

  <p>However, no such datastructures are specified by the Scheme
  standard, and preceding this SRFI, no attempt has been made to
  specify a standard API for these most common datastructures. It
  is anticipated that this will change in the near future. In
  advance of these specifications, this SRFI will outline a
  consistent naming scheme and set of operators and semantics that
  future data structure specifications may follow. The intended
  result is to allow current and future standard datastructures to
  look and behave in a predictable fashion, and to allow the values
  stored in them to be easily and efficiently transferred to and
  from different datastructures as necessary.</p>

  <p>This SRFI specifies a folding enumerator as the primary means
  of traversing and obtaining all values of a collection. The
  rationale for this paradigm is to support a diverse variety of
  collections whose contents may reside in memory, slow secondary
  storage, over networks, or as results of computational processes.
  The folding enumerator allows for precise control over the
  resources of the underlying collection, while still providing
  flexible generic access to collections.</p>

  <p>Allowing stepwise enumeration over a collection, as opposed to
  a <tt>collection-&gt;list</tt> function allows the collection
  enumerator to fetch its elements lazily from some slower or more
  costly storage or retrieval mechanism. The canonical example is a
  collection whose elements are rows from a complex database query.
  While it may not be possible to store the entire results of the
  query in memory on which a <tt>map</tt> or <tt>for-each</tt>
  operation could be performed, it may be much more feasible to
  allow the enumerator to fetch each row one at a time, saving both
  memory and delay in transfering the results to the Scheme
  program. Additionally, the enumerator may cooperate much more
  cleanly with a garbage collector as references to each value
  retrieved can be discarded after processing, allowing the garbage
  collector to free large values immediately if the Scheme program
  does not itself capture a reference to the collection value. It
  has also been shown that enumeration can be the basis for other
  traversal protocols such as cursors, through straightforward
  conversion operators. Finally, the enumeration protocol described
  allows for early termination by the accessing function, which may
  obviate the need to transfer many unaccessed future elements.</p>

  <H1><a name="specification">Specification</a></H1>

  <blockquote>
    <h2><a name="chier">Collections Hierarchy</a></h2>

    <center>
      <table>
        <tbody>
          <tr>
            <td>
              <pre>
              Collection                        
                  |         
         +--------+---------+
         |        |         |                 
        Bag      Set       Map
         |                  
      Sequence           
         |   
 Flexible Sequence  
</pre>
            </td>
          </tr>
        </tbody>
      </table>
    </center>

    <p>This SRFI first defines a hierarchy of possible
    datastructure types. Each subtype inherits the behavior and
    functionality of it's parent (its interfaces). Any collection
    may be immutable.</p>

    <blockquote>
      <h4>Collection</h4>

      <p>The base type. All collections have a concept of size and
      emptiness, and it is possible to perform a folding
      enumeration over the values of any collection.</p>

      <h4>Bag</h4>

      <p>A bag is a collection of possibly ordered, possibly unique
      values. Given a bag, it is only possible to determine if it
      contains or does not contain any of a given value.</p>

      <h4>Set</h4>

      <p>A set is a collection of unique values. Similar to but
      distinct from a bag, it is only possible to determine if a
      set contains or does not contain a given value. Unlike a bag,
      only one of any value can exist in the collection at a time.
      Removing one value from the set means that the set no longer
      contains the value at all.</p>

      <h4>Sequence</h4>

      <p>A sequence extends a bag with the ability to access and
      replace all of its members using a contiguous sequence of
      non-negative exact integers. Sequences are <i>stable.</i>
      That is, if no mutation operation occurs on a sequence, its
      elements must remain in the same order according to their
      previously observed indices. When values are added to a base
      Sequence, they may be added anywhere in the sequence.
      Sequences may or may not allow multiple instances of a
      value.</p>

      <h4>Flexible Sequence</h4>

      <p>A flexible sequence is a datastructure that allows new
      values to be added and old values removed at any position in
      the sequence, as specified by the programmer.</p>

      <h4>Map</h4>

      <p>A map is a collection which stores associations between
      single keys and single values. Maps typically provide better
      than linear time retrieval of the value given a key.</p><!--
                <h4>
                  Dictionary
                </h4>
                <p>
                  The dictionary collection is similar to a map, but allows
                  multiple mappings to exist from one key to numerous values
                  (in other words an n-to-m mapping).  
                </p> -->
    </blockquote>

    <h2><a name="typing">Typing</a></h2>

    <p>This SRFI uses the word type to refer to a class of
    datastructures as a whole, and subtyping to refer to classes of
    datastructures who have the properties of and pass the type
    checking predicates of their parents. This however is a
    metaphor used to more concisely describe the signatures of
    operators that each concrete collection must provide. It does
    not necessarily map to any actual type system or inheritance
    rules. Implementations are permitted to use type systems to
    enforce or facilitate providing the correct set of operators
    and behaviors, but this is not required.</p>

    <h2><a name="attribute">Collection Attributes</a></h2>

    <p>In addition to the conceptual type hierarchy which dictates
    the available functions for a given collection, collections
    also may possess any of three (in this SRFI) attributes which
    specify whether certain global functions are well defined for
    the collection. Attributes may also specify additional
    parameters to the collection's constructor.</p>

    <p>This SRFI specifies four such attributes:
    <i>orderedness</i>, <i>directionality</i>, <i>mutability</i>,
    and <i>limitedness</i>.</p>

    <blockquote>
      <h3><a name="ordered">Ordered Collections</a></h3>

      <p>Ordered collections maintain an ordering to their values
      (or in the case of maps, their keys) which is based on those
      values' relationships to each other. The collection fold is
      guaranteed to enumerate over the collection's values/keys in
      increasing value precedence as defined by the collection's
      <i>ordering function</i>.</p>

      <h3><a name="directional">Directional Collections</a></h3>

      <p>Directional collections have a notion of a left/right
      handedness to their interface which is independent of any
      relationships between their values. For example, sequences
      are always directional collections, for which the left side
      implies lower indices, while the right side implies higher
      indices. Directional collections must provide operators to
      retrieve the left and rightmost values, and may provide
      update operators to add or delete values to/from the left and
      right hand sides of the collection. This is useful for
      non-sequences as well, for example to implement a queue
      datastructure as a bag.</p>

      <p>Directional collections provides</p>

      <p>A collection cannot be both ordered and directional
      simultaneously. The left and right accessors of ordered
      collections access least-precedent and most-precedent values,
      rather than the left and right values which are unrelated to
      precedence in directional collections.</p>

      <h3><a name="limitedcollections">Limited Collections</a></h3>

      <p>Limited collections are collections with a fixed capacity
      and thus a fixed maximum size. It may be possible to add and
      remove values from limited collections by using a special
      value to indicate unused slots in the underlying
      representation, so limited collections do not necessarily
      have fixed size. Update procedures which add or remove values
      from a limited collection may be undefined on limited
      collections.</p>

      <h3><a name="mutable">Purely Mutable Collections</a></h3>

      <p>This SRFI's API is accommodating to purely functional and
      linear-updating collections by default. Some collections may
      be <i>purely mutable</i>. That is, updates are done purely
      through side effects within the collection. In such a
      collection,</p>
      <pre>
(eq? &lt;input collection&gt; (update-procedure  &lt;input collection&gt;))
</pre>will always return <tt>#t</tt>. Much Scheme code is often
written to such purely mutable collections (hash tables are an
example). It is not possible to support these collections by
requiring that code use the side-effecting procedures defined in
this SRFI in the linear-update fashion, as it would require
significant changes to such code and could be expensive in terms of
unnecessarily allocated storage.<br>
      <br>

      <p>For these reasons, <i>pure mutability</i> is an additional
      attribute that may be held by a collection. When so held, the
      results of the side-effecting update procedures may be
      ignored, Programmers may then utilize these procedures in the
      usual manner and agnostic to the collection type so long as
      the pure mutability attribute is checked. Note that purely
      mutable collections exist comfortably within the protocol for
      linear update procedures, so code written to the latter will
      accomodate the former with no changes.</p>
    </blockquote>

    <h2><a name="storagemodel">Storage Model</a></h2>

    <p>Collection instances, as specified in this SRFI, must be
    treated as first-class values. This means they must be storable
    in any variable or heterogenous datastructure. Collections may
    be divisible, that is, may be composed as combinations of
    like-typed collections. This SRFI defines modification
    operators for both purely functional and any range of mutable
    datastructures.</p>

    <h2><a name="dispatch">Dispatch Mechanism</a></h2>

    <p>The precise mechanism of dispatch for collection operators
    capable of receiving multiple collection types is deliberately
    unspecified. Many existing Scheme systems have generic
    procedure functionality and/or object oriented extensions that
    permit dispatch of functions based on the type of their
    arguments. In other cases, self-contained programs may wish to
    include a small, fixed set of collections and eschew the
    overhead of a generic dispatch system, instead relying on
    simple dispatch using explicit type checking (for example with
    a <tt>cond</tt> statement). This SRFI is designed to allow
    integration with any of those systems. Should a standard
    dispatch system emerge in the future, this SRFI can be cleanly
    integrated with it.</p>

    <p>In the case where a generic dispatch system is used, it
    needs only a minimum set of features. In particular, a single
    dispatch system should be sufficient to implement collection
    extension, as all operators where more than one generic type
    may be passed can be implemented in terms of generic dispatch
    on the first argument and utilization of a second generic
    operator for its implementation. For example,
    <tt>*-add-from</tt> need only dispatch on the primary
    collection, and can use the fold operator to iterate through
    the second collection's values to add them.</p>

    <p>Future SRFIs may add additional abstract collection types,
    but such types <i>must</i> inherit their interface singly from
    an existing abstract type (including the base collection type)
    in this SRFI. Concrete collection types can inherit from an
    abstract type or other concrete types, but abstract types may
    not inherit their interface from a concrete type. For example,
    a new hash-table map type will be a <tt>hash-table?</tt>, and a
    <tt>map?</tt> but cannot also be an <tt>alist-map?</tt>.</p>

    <h2><a name="foldingenums">Folding Enumerators</a></h2>

    <p>Regardless of the collection type, all collections must be
    supported by the generic folding enumeration procedures,
    <tt>collection-fold-left</tt> and
    <tt>collection-fold-right</tt> in addition to providing
    concrete fold operators specific to the collection type
    (<tt>%-fold-left, %-fold-right</tt>) (see <a href=
    "#procedures">Procedures</a>). The collection fold procedures
    take a collection and a folding function as arguments, as well
    as any number of optional seed values. The collection fold
    procedures then invoke the folding function on a value of the
    collection and the seeds, and receive from the folding function
    a <i>proceed</i> value followed by a like number of seed return
    values. If the proceed value is non-false, the collection fold
    procedure then invokes the same fold function again with the
    next collection value and the newly returned seed values. This
    continues until the elements of the collection are exhausted,
    or the fold function returns false as the proceed value, at
    which point the collection fold procedure returns the seed
    values (if any) returned by the last call to the fold
    function.</p>In an ordered collection, the left fold procedure
    is required to apply the values in the order of the underlying
    ordered collection. In addition, an ordered collection must
    apply the values in the reverse order as the left fold when
    enumerated by <tt>collection-fold-right</tt>. Likewise, the
    left fold procedure must proceed through the values of a
    sequence in increasing index order, while the right fold
    proceeds in decreasing index order.<br>
    <br>

    <p>Finally, all Map and Sequence datastructures must be
    supported by <tt>collection-fold-keys-left</tt> and
    <tt>collection-fold-keys-right</tt> which during enumeration
    applies the fold function to both the map's keys or the
    sequence's indices and their corresponding values.</p>

    <blockquote>
      <h3><a name="stability">Enumeration Stability</a></h3>

      <p>It is undefined in this SRFI whether the process of
      enumeration over a collection is <i>stable</i>. A stable
      enumeration will enumerate over the values that exist in a
      given collection at a certain time. Removing, adding, or
      changing values from the underlying collection while
      enumerating will not cause those values to be missing,
      discovered, or the new value observed respectively in future
      steps of the enumeration. Modifying a collection while
      enumerating is permitted to cause an error in either the
      collection modification or in the enumeration, though this
      behavior is discouraged.</p>

      <p>Enumerations must, however, be stable in the absence of
      updates. That is, once started, an enumeration should touch
      all values in the collection (in the proper order as
      described above) so long as no updates are performed on the
      underlying collection. Enumerations need not be stable
      between each other. That is, though an enumeration may be
      internally stable, a second enumeration need not return the
      values in the same order, unless the collection type and
      attributes require this as described above.</p>

      <p>Note that if a collection is purely functional, it will by
      definition be stable in the presence of modification, as the
      modified collection will be space-distinct from the
      enumerated collection.</p>
    </blockquote>

    <h2><a name="equivalence">Equivalence</a></h2>

    <p>Collections are considered equivalent with respect to
    Scheme's <tt>equal?</tt> operator when they are of the same
    type and contain a like number of values or mappings, and where
    each value/mapping in one collection is <tt>equal?</tt> to a
    value in the second collection.</p>

    <p>For sequences and ordered collections the ordering of the
    contained values must also be equivalent. For maps, each key in
    the first map must be equal to a key in the second map, and the
    value(s) mapped to by that key in each map must also be
    equivalent. If the map is ordered, the order of the mappings
    must also be the same.</p>

    <p>Equivalence is checked with this SRFI's <tt>*=</tt>
    operator, described later. Implementations may also extend
    Scheme's <tt>equal?</tt> and <tt>eqv?</tt> operators to
    collections, as long as the above semantics hold for
    <tt>equal?</tt>. In other words,</p>
    <pre>
(equal? <i>collection ...</i>)
        
</pre>must return the same value as
    <pre>
(collection= equal? <i>collection ...</i>)
        
</pre>if the collections are of the same type, otherwise it must
return false.<br>
    <br>

    <h2><a name="immutablecols">Immutable Collections</a></h2>

    <p>Any collection or instance of a collection may be immutable,
    or made immutable at any point in its lifecycle. It is an error
    to add, remove, or modify any values or mappings in an
    immutable collection.</p>

    <h2><a name="homogeneity">Homogeneity</a></h2>

    <p>Collections may be homogeneous (capable of storing values of
    only one type), though it is anticipated that the majority of
    collections will be heterogenous. If a collection is
    homogeneous, it is an error to attempt to store a value or key
    of the wrong type within it.</p>

    <h2><a name="sizevslength">Size versus Length</a></h2>

    <p>Most collections possess a concept of size. The size of a
    collection is the number of values or mappings it currently
    contains. This differs from the concept of length in Scheme
    datastructures, which corresponds to the number of cons cells
    or vector slots the structure contains. A collection may
    contain more cells or slots than required to contain its values
    or mappings. An example might be a hashtable collection, which
    may at any given time contain numerous unoccupied,
    discontiguous cells. This matter is confused by the collections
    specified in this API, whose size and length may be the
    same.</p>

    <p>Put another way, <tt>collection-size</tt> should return the
    number of enumeration steps that will occur, if known.</p>

    <p>A collection may not have such a concept, in which case the
    <tt>collection-size</tt> function must return <tt>#f</tt>.
    Infinite collections (such as the collection of natural
    numbers) or lazy collections (such as a network stream) are
    examples of size-indeterminate collections.</p>

    <h2><a name="infcoll">Infinite Collections</a></h2>

    <p>Infinite collections are collections which contain or
    generate a potentially unlimited number of values. Infinite
    collections must return <tt>#f</tt> from the
    <tt>collection-size</tt> function. Enumerations over an
    infinite collection may proceed indefinitely, and may be
    haltable only via the folding function.</p>

    <p>Furthermore, left enumeration over an infinite collection
    should whenever possible not require an unboundedly increasing
    amount of storage as the enumeration proceeds. It should be
    possible to enumerate indefinitely without consuming a fatal
    amount of resources assuming the fold function does not
    contribute to resource consumption. The behavior of
    <tt>collection-fold-right</tt> is undefined on infinite
    collections. Furthermore, the collection fold operators are
    strict. Applying a fold operator to a stream will force each of
    its values as they are applied to the fold function.</p>

    <p>Some collections may use a self-referential representation,
    such as the circular list for redundant value access. The
    purpose of these collections is not to appear to contain an
    infinite number of values, and are thus <i>not</i> considered
    infinite. Naive iteration may proceed indefinitely, but the
    folding enumerations of this SRFI must halt after enumerating
    over the actual values of such a collection.
    <tt>collection-size</tt> should return the number of actual
    values in the collection unless it cannot efficiently do
    so.</p>

    <h2><a name="orderedcols">Ordered Collections</a></h2>

    <p>Some collections maintain an ordering. These ordered
    collections provide the additional property of guaranteeing a
    left fold will progress over the collection in a least to
    greatest value precedence fashion, as defined by the
    collection's <i>ordering function</i>. An ordered collection's
    constructor must take such a function as input. An ordering
    function takes two arguments, and returns a boolean, indicating
    whether the first value is to take precedence in the collection
    over the second. As an example, an ordered collection of
    numbers may use <tt>&lt;</tt> or <tt>&lt;=</tt> to order
    numeric values added to the collection.</p>

    <p>In order to ensure a consistent ordering in the collection,
    the ordering function must return the same result for like
    inputs over time (i.e. it must be functional). In most cases,
    an ordering function should also treat like values as if tested
    using <tt>equal?</tt> in order to ensure that duplicate values
    are stored and retrieved consistently.</p>

    <p>Many collections may derive the equivalence function from
    the ordering function since the ordering function has the
    property of being strict weak. It is suggested that ordered
    collections do so if no equivalence function is provided by the
    programmer. Otherwise the collection should document its
    behavior in this respect.</p>

    <h2><a name="valueequality">Bags, Sets, Maps and Value
    Equality</a></h2>

    <p>Maps store mappings from keys to values. Bags and Sets store
    values in an opaque fashion which only indicates the presence
    or absence of an object. In order to determine whether a given
    value exists in a set or bag, or whether a given key matches
    another in a map, these collections must use an <i>equivalence
    function.</i> Other collections may use equivalence functions
    for other purposes.</p>

    <p>Any collection may require or accept an equivalence function
    in its primary constructor (<tt>make-%</tt>) and in its
    initializing constructor (<tt>%</tt>). The provided equivalence
    function must take two values as input and return true if they
    should be considered equivalent for the purposes of
    <tt>contains?</tt>, value insertion, or removal. If provided,
    an equivalence function follows an ordering function in an
    ordered collection, but precedes any other arguments. If not
    provided, <tt>eqv?</tt> is used as a default equivalence
    function.</p>

    <p>Maps additionally may take a second equivalence function for
    comparing keys. Thus, the initializing constructor for a map
    which accepts user-defined equivalence functions takes the form
    <tt>(% [value-equivalence-function [key-equivalence-function]]
    ...)</tt> . If not provided, the map must use the value
    equivalence function for comparing values and keys.</p>

    <h2><a name="sequences">Sequences</a></h2>

    <p>A sequence is a directional collection of values named by a
    contiguous sequence of exact integers in the range
    [0,<tt>(collection-size sequence)</tt>). Scheme vectors are a
    natural example of a sequence. Sequences may or may not be of
    fixed size. If they are not, sequences allow new values to be
    added at an undefined point in the sequence, after which some
    value will exist at the index <tt>(- (collection-size
    <i>sequence</i>) 1)</tt>.</p>

    <p>Sequences may allow other indices outside the range
    specified above to retrieve values that can also be retrieved
    with indices inside the normal range. For example, a circular
    list sequence may allow you to retrieve the last value at
    position <tt>(- (collection-size seq) 1)</tt> and at position
    <tt>-1</tt>. Such extensions must be well documented in the
    specification of that sequence.</p>

    <blockquote>
      <h3><a name="flexsequences">Flexible Sequences</a></h3>

      <p>Flexible sequences are sequences which allow insertion of
      values at arbitrary points in the sequence. Inserting a value
      at any position except the end of the sequence causes all
      values with higher indices than the insertion point to
      <i>shift right</i>, thus having an index increased by one.
      Similarly, if values are removed from a sequence at any
      position except the end, all values with higher indices are
      <i>shifted left</i>, so their former indices are now
      decreased by one.</p>
    </blockquote>

    <h2><a name="procedures">Procedures</a></h2>

    <p>Below we describe the naming conventions and semantics of
    Collections API functions, grouped by collection type. In each
    function, the name of the collection would replace the
    percentage mark in the function prototype. Function definitions
    in child collection types or in attributes absolutely override
    the same named function in the parent. For example
    <tt>make-%</tt> in the ordered collection requires an
    equivalence function while general collection constructors do
    not.</p>

    <p>When <tt>*</tt> is encountered in the definitions below, it
    is implied that the asterisk is replaced with a function for
    the name of the section type and all of its subtypes. For
    example, if we had a 'list' flexible sequence collection, the
    functions <tt>list-contains?</tt>,
    <tt>flexible-sequence-contains?</tt>,
    <tt>sequence-contains?</tt>, <tt>bag-contains?</tt> must all
    exist, but <tt>collection-contains?</tt> does not. In addition,
    it is an error to apply any such function to a collection whose
    type does not satisfy that implied by the function name.</p>

    <p>Encountering <tt>*</tt> as a function argument indicates
    that the argument must be a collection of the type the function
    is defined for, or any sub-type. These functions are
    polymorphic on the input collection type.</p>

    <p>When <tt>%</tt> is encountered in the definitions below, the
    actual name of the collection is implied. Again, assuming a
    'list' flexible sequence, <tt>make-%</tt> implies that the
    function <tt>make-list</tt> exists. <tt>%</tt> as a return
    value indicates a collection of that specific type.</p>

    <p>Encountering <tt>%</tt> as a return type indicates that a
    collection of the same type as the input is returned.</p>

    <p>Occasionally an operator will be specified in a collection
    subtype which was already defined in a supertype or by an
    attribute which the collection subtype is known to support.
    This is done to clarify the semantics of the operator as
    defined for that specific subtype.</p>

    <p>Finally, some procedures defined below indicate more than
    one item as a return value (following <tt>=&gt;</tt> in the
    definition.) These procedures do in fact return more than one
    value as multiple Scheme values. These values are returned as
    if by the <tt>values</tt> Scheme function, <i>not</i> as a
    Scheme list.</p>

    <blockquote>
      <h3><a name="flup">Functional, Linear Update, and Purely
      Mutable Collections</a></h3>

      <p>Functions in this SRFI which modify a collection are
      provided in two flavors. Both <i>must</i> be implemented by
      collections. Purely functional updating functions must not
      side effect the input collection, but must return a new
      collection which reflects the update. The returned collection
      may share structure with the input collection, but the
      effects of the update must <i>not</i> be reflected in the
      input collection.</p>

      <p>The linear update/purely mutable update operators share
      the name of the functional update function but have the bang
      (!) character appended. They too return a collection, which
      is allowed to be the same as and/or share structure with the
      input collection. However, side-effects to the input
      collection are allowed. The caller <i>must</i> use the
      returned collection to view the effects of the update. The
      structure of the input collection after the modification is
      undefined.</p>

      <p>Purely mutable collections will <i>only</i> side effect
      the input collection. They will therefor always return the
      input collection as the output collection. The programmer may
      ignore the resulting value if she is certain that the
      collection is purely mutable. Operating on the input
      collection after an update to a linear updating collection
      may have unexpected results.</p>

      <p>A collection may naturally be amenable to either purely
      functional or purely side-effected updates. In the former
      case, the linear updating version of the procedure may return
      the purely functionally updated collection. This does not
      conflict with the definition of the linear update procedure.
      Conversely, the purely functional updating function can
      return a distinct collection by cloning a collection which
      cannot be functionally updated, and performing the
      side-effecting modifications to the clone of the input
      collection.</p>

      <p>As the case of functionally updating a collection whose
      structure is updatable only using side-effects can be
      expensive (due to the worst-case need to clone a large
      collection), the specifications of all collections are highly
      encouraged to document the nature of their compatibility and
      efficiency for both the functional and side-effecting update
      functions.</p>

      <h3><a name="enumprocs">Enumeration</a></h3><i>procedure:</i>
      <b>collection-fold-left</b> collection fold-function seed ...
      <b>=&gt;</b> seed ...<br>
      <i>procedure:</i> <b>%-fold-left</b> % fold-function seed ...
      <b>=&gt;</b> seed ...<br>

      <blockquote>
        <i>fold-function</i> is a procedure which accepts one more
        than the number of seed values. The function accepts a
        single collection value as its first argument, and the
        seeds as remaining arguments. It must then return a
        <i>proceed</i> value, which if false halts the enumeration,
        as well as an equal number of returned seed values as
        arguments. These seed values are then passed to the next
        call to the fold function on the next collection value.<br>
        <br>
        When the collection values are exhausted or a false proceed
        value is received from the fold function, the enumeration
        ceases and the fold operator returns the last set of seed
        values returned by the fold-function.
      </blockquote><i>procedure:</i> <b>collection-fold-right</b>
      collection fold-function seed ... <b>=&gt;</b> seed ...<br>
      <i>procedure:</i> <b>%-fold-right</b> % fold-function seed
      ... <b>=&gt;</b> seed ...<br>

      <blockquote>
        Behaves like <tt>collection-fold-left</tt>, except that the
        fold function is applied to the values of the collection in
        reverse order.
      </blockquote><i>procedure:</i>
      <b>collection-fold-keys-left</b> collection fold-function
      seed ... <b>=&gt;</b> seed ...<br>
      <i>procedure:</i> <b>%-fold-keys-left</b> % fold-function
      seed ... <b>=&gt;</b> seed ...<br>

      <blockquote>
        <p>Behaves like <tt>collection-fold-left</tt>, but
        enumerates over the keys or indices of a map or sequence
        respectively as well as the corresponding values. This
        procedure is only defined for sequences and maps.</p>

        <p>Also, the fold function of a key enumerator must accept
        <i>two</i> more operands than the number of seed values.
        The first two operands to the function are the key and
        corresponding value at the current point in the
        enumeration.</p><!--
                    <p>
                    Dictionaries should present one key/value pair at a
                    time to the fold function.  In other words, if 
                    two values are mapped by a single key, the fold function
                    is called twice, the first time with the key and the first
                    value, and the second time with the key and the second
                    value.  
                    </p>-->
      </blockquote><i>procedure:</i>
      <b>collection-fold-keys-right</b> collection fold-function
      seed ... <b>=&gt;</b> seed ...<br>
      <i>procedure:</i> <b>%-fold-keys-right</b> % fold-function
      seed ... <b>=&gt;</b> seed ...<br>

      <blockquote>
        Behaves like <tt>collection-fold-keys-left</tt>, but
        enumerates in the reverse order over the keys or indices of
        an ordered map or sequence and values. This procedure is
        only defined for sequences and ordered maps.
      </blockquote>

      <h3><a name="collprocs">Collections</a></h3>

      <p><i>procedure:</i> <b>collection?</b> value <b>=&gt;</b>
      value</p>

      <blockquote>
        Returns a non-false value if the provided value is a
        collection.
      </blockquote>

      <p><i>procedure:</i> <b>collection-name</b> collection
      <b>=&gt;</b> symbol (%)</p>

      <blockquote>
        Returns the collection name of the provided collection. The
        name is a symbol containing the type name of the specific
        collection. A collection whose constructor is make-list,
        for example, would have the symbol <tt>list</tt> returned
        from <tt>collection-name</tt>
      </blockquote>

      <p><i>procedure:</i> <b>%?</b> value <b>=&gt;</b> value</p>

      <blockquote>
        Returns a non-false value iff the provided value is an
        instance of the specific collection type.
      </blockquote>

      <p><i>procedure:</i> <b>*-size</b> * <b>=&gt;</b> exact
      integer</p>

      <blockquote>
        If the collection has a concept of size, this function
        returns the number of actual values in the collection (or
        mapped values in a map) If it does not, <tt>#f</tt> must be
        returned. When an integer is returned from this function,
        it indicates that an enumeration will proceed exactly
        <tt>*-size</tt> steps in the absence of any updates.
      </blockquote>

      <p><i>procedure:</i> <b>*-count</b> * value<b>=&gt;</b> exact
      integer</p>

      <blockquote>
        Counts the number of times <tt>value</tt> occurs in the
        collection, according to the collection's equivalence
        function.
      </blockquote>

      <p><i>procedure:</i> <b>*-get-any</b> *
      [absence-thunk]<b>=&gt;</b> value</p>

      <blockquote>
        Returns a value from the given collection. It is
        unspecified which of its values is returned. If the
        collection is empty, <tt>absence-thunk</tt> is invoked if
        present and its value returned, otherwise <tt>#f</tt> is
        returned.
      </blockquote>

      <p><i>procedure:</i> <b>*-empty?</b> * <b>=&gt;</b>
      boolean</p>

      <blockquote>
        Returns a non-false value iff the given collection is known
        to be empty. This function should return false if it is
        known that there are values within the collection, or if it
        is unknown whether any values exist.
      </blockquote>

      <p><i>procedure:</i> <b>*-&gt;list</b> * <b>=&gt;</b>
      list</p>

      <blockquote>
        Returns a newly allocated list containing the values of the
        collection. This can be done trivially with enumeration,
        but an implementation may choose to allow this function to
        behave more efficiently on certain collections. If the
        collection is ordered, the list must contain the values of
        the collection in the same order as the left collection
        fold.
      </blockquote>

      <p><i>procedure:</i> <b>*-clear</b> * <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-clear!</b> * <b>=&gt;</b> %</p>

      <blockquote>
        Clears the collection. In all cases a collection of the
        same type as the input is returned with no values or
        mappings. It is an error to clear an immutable collection
        and may be an error to clear a limited collection.
      </blockquote>

      <p><i>procedure:</i> <b>*=</b> elt= * ... <b>=&gt;</b>
      boolean</p>

      <blockquote>
        <p>Compares the provided (zero or more) collections for
        equivalence given the equivalence predicate <tt>elt=</tt>.
        If fewer than two collections are provided, a non-false
        value is returned. For any other number of collections, the
        collections are compared pairwise from left to right. As
        soon as any two collections contain different numbers of
        values or mappings, or their values aren't equivalent as in
        the section "Equivalence" above with the provided
        <tt>elt=</tt> function used for value comparison, false is
        returned. If all collections are equivalent, a non-false
        value is returned.</p>
      </blockquote>

      <p><i>procedure:</i> <b>make-% =&gt;</b> %</p>

      <blockquote>
        Constructs a % collection.
      </blockquote>

      <p><i>procedure:</i> <b>%</b> value ... <b>=&gt; %</b></p>

      <blockquote>
        Constructs a % collection with zero or more values provided
        as its initial contents.
      </blockquote>

      <p><i>procedure:</i> <b>*-copy</b> * <b>=&gt;</b> %</p>

      <blockquote>
        Creates a new collection whose type and contents are the
        same as the collection passed as an operand, but which is
        distinct enough in storage that the new collection cannot
        be affected by modifications to the input collection and
        vice versa. This copy is <i>shallow</i>, that is, values
        are copied to the new collection in a way that preserves
        object identity.
      </blockquote>

      <h3><a name="orderedcollprocs">Ordered Collections</a></h3>

      <p><i>procedure:</i> <b>ordered-collection?</b> value
      <b>=&gt;</b> value</p>

      <blockquote>
        Returns a non-false value if the provided value is an
        ordered collection.
      </blockquote>

      <p><i>procedure:</i> <b>*-ordering-function</b> *
      <b>=&gt;</b> procedure</p>

      <blockquote>
        Returns the ordering function of the provided ordered
        collection.
      </blockquote>

      <p><i>procedure:</i> <b>*-get-left</b> *
      [absence-thunk]<b>=&gt;</b> value</p>

      <blockquote>
        Returns the leftmost (least precedent) value in the ordered
        collection. If the collection is empty,
        <tt>absence-thunk</tt> is invoked if present and its value
        returned, otherwise <tt>#f</tt> is returned.
      </blockquote>

      <p><i>procedure:</i> <b>*-get-right</b> *
      [absence-thunk]<b>=&gt;</b> value</p>

      <blockquote>
        Returns the rightmost (most precedent) value in the ordered
        collection. If the collection is empty,
        <tt>absence-thunk</tt> is invoked if present and its value
        returned, otherwise <tt>#f</tt> is returned.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-left</b> * <b>=&gt;</b> %
      value<br>
      <i>procedure:</i> <b>*-delete-left!</b> * <b>=&gt;</b> %
      value</p>

      <blockquote>
        Removes the leftmost (least precedent) value from the
        collection, returning two values, the updated collection
        and the value removed.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-right</b> * <b>=&gt;</b> %
      value<br>
      <i>procedure:</i> <b>*-delete-right!</b> * <b>=&gt;</b> %
      value</p>

      <blockquote>
        Removes the rightmost (most precedent) value from the
        collection, returning two values, the updated collection
        and the value removed.
      </blockquote>

      <p><i>procedure:</i> <b>make-%</b> ordering-function <b>=&gt;
      %</b></p>

      <blockquote>
        Constructs a % ordered collection whose ordering is
        determined by the provided ordering function.
      </blockquote>

      <h3><a name="limitedcollprocs">Limited Collections</a></h3>

      <p><i>procedure:</i> <b>limited-collection?</b> value
      <b>=&gt;</b> value</p>

      <blockquote>
        Returns a non-false value if the provided value is an
        limited collection.
      </blockquote>

      <h3><a name="mutablecollprocs">Purely Mutable
      Collections</a></h3>

      <p><i>procedure:</i> <b>purely-mutable-collection?</b> value
      <b>=&gt;</b> value</p>

      <blockquote>
        Returns a non-false value if the provided value is a purely
        mutable collection.
      </blockquote>

      <h3><a name="directionalcollprocs">Directional
      Collections</a></h3>

      <p><i>procedure:</i> <b>directional-collection?</b> value
      <b>=&gt;</b> value</p>

      <blockquote>
        Returns a non-false value if the provided value is a
        directional collection.
      </blockquote>

      <p><i>procedure:</i> <b>*-get-left</b> *
      [absence-thunk]<b>=&gt;</b> value</p>

      <blockquote>
        Returns the leftmost value in the directional collection,
        as defined by the collections notion of left/right
        handedness. If the collection is empty,
        <tt>absence-thunk</tt> is invoked if present and its value
        returned, otherwise <tt>#f</tt> is returned.
      </blockquote>

      <p><i>procedure:</i> <b>*-get-right</b> *
      [absence-thunk]<b>=&gt;</b> value</p>

      <blockquote>
        Returns the rightmost value in the directional collection,
        as defined by the collections notion of left/right
        handedness. If the collection is empty,
        <tt>absence-thunk</tt> is invoked if present and its value
        returned, otherwise <tt>#f</tt> is returned.
      </blockquote>

      <p><i>procedure:</i> <b>*-insert-left</b> * value<b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-insert-left!</b> * value<b>=&gt;</b>
      %</p>

      <blockquote>
        Adds a value to the leftmost position in the directional
        collection. A directional collection may not support this
        operation, but if it does, it must ensure that:
        <pre>
      (*-get-left (*-insert-left &lt;*&gt; &lt;value&gt;)) ;=&gt; &lt;value&gt;
</pre>
      </blockquote>

      <p><i>procedure:</i> <b>*-insert-right</b> *
      value<b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-insert-right!</b> * value<b>=&gt;</b>
      %</p>

      <blockquote>
        Adds a value to the rightmost position in the directional
        collection. A directional collection may not support this
        operation, but if it does, it must ensure that:
        <pre>
      (*-get-right (*-insert-right &lt;*&gt; &lt;value&gt;)) ;=&gt; &lt;value&gt;
</pre>
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-left</b> * <b>=&gt;</b> %
      value<br>
      <i>procedure:</i> <b>*-delete-left!</b> * <b>=&gt;</b> %
      value</p>

      <blockquote>
        Removes the leftmost value from the directional collection,
        returning two values, the updated collection and the value
        removed. A directional collection may not support this
        operation, but if it does, it must preserve the following
        semantics:
        <pre>
      (let ((col (make-* values ...)))
        (call-with-values 
           (lambda ()
             (*-delete-left (*-insert-left * a-value)))
           (lambda (newcol val)
             (*= equal? col newcol)))) ; =&gt; #t
</pre>
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-right</b> * <b>=&gt;</b> %
      value<br>
      <i>procedure:</i> <b>*-delete-right!</b> * <b>=&gt;</b> %
      value</p>

      <blockquote>
        Removes the rightmost value from the directional
        collection, returning two values, the updated collection
        and the value removed. A directional collection may not
        support this operation, but if it does, it must preserve
        the following semantics:
        <pre>
      (let ((col (make-* values ...)))
        (call-with-values 
           (lambda ()
             (*-delete-right (*-insert-right * a-value)))
           (lambda (newcol val)
             (*= equal? col newcol)))) ; =&gt; #t
</pre>
      </blockquote>

      <h3><a name="bagprocs">Bags</a></h3>

      <p><i>procedure:</i> <b>bag?</b> value <b>=&gt;</b> value</p>

      <blockquote>
        Returns a non-false value if the provided value is a bag.
      </blockquote>

      <p><i>procedure:</i> <b>*-equivalence-function</b> *
      <b>=&gt;</b> procedure</p>

      <blockquote>
        Returns the equivalence function for the given bag.
      </blockquote>

      <p><i>procedure:</i> <b>*-contains?</b> * value <b>=&gt;</b>
      boolean</p>

      <blockquote>
        Returns a non-false value if the bag contains any instances
        of the given value.
      </blockquote>

      <p><i>procedure:</i> <b>*-add</b> * value <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-add!</b> * value <b>=&gt;</b> %</p>

      <blockquote>
        Adds a single value to a bag.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete</b> * value <b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-delete!</b> * value <b>=&gt;</b> %</p>

      <blockquote>
        Removes a single instance of the given value from the bag.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-all</b> * value <b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-delete-all!</b> * value <b>=&gt;</b>
      %</p>

      <blockquote>
        Removes any instances of the given value from the bag.
      </blockquote>

      <p><i>procedure:</i> <b>*-add-from</b> * source-bag
      <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-add-from!</b> * source-bag
      <b>=&gt;</b> %</p>

      <blockquote>
        Adds all the values in the source bag to the destination
        (first argument).
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-from</b> * source-bag
      <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-delete-from!</b> * source-bag
      <b>=&gt;</b> %</p>

      <blockquote>
        Removes one instance of each value found in source-bag from
        the destination (first argument).
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-all-from</b> * source-bag
      <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-delete-all-from!</b> * source-bag
      <b>=&gt;</b> %</p>

      <blockquote>
        Removes any instances of each value found in source-bag
        from the destination (first argument).
      </blockquote>

      <h3><a name="setprocs">Sets</a></h3>

      <p><i>procedure:</i> <b>set?</b> value <b>=&gt;</b>
      boolean</p>

      <blockquote>
        Returns a non-false value if the provided value is a set.
      </blockquote>

      <p><i>procedure:</i> <b>*-equivalence-function</b> *
      <b>=&gt;</b> procedure</p>

      <blockquote>
        Returns the equivalence function for the given set.
      </blockquote>

      <p><i>procedure:</i> <b>*-contains?</b> * value <b>=&gt;</b>
      boolean</p>

      <blockquote>
        Returns a non-false value if the set contains the given
        value.
      </blockquote>

      <p><i>procedure:</i> <b>*-subset?</b> * sets ... <b>=&gt;</b>
      boolean</p>

      <blockquote>
        Returns a non-false value if the input set is a subset
        (that is, equal to or a strict subset of) the remaining
        sets. If only the input set is provided, a non-false value
        is returned, otherwise the set is compared tested to be a
        subset of each remaining set in left to right order. As
        soon as the set is not a subset of any one argument,
        <tt>#f</tt> is returned.
      </blockquote>

      <p><i>procedure:</i> <b>*-add</b> * value <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-add!</b> * value <b>=&gt;</b> %</p>

      <blockquote>
        Adds a value to the set.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete</b> * value <b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-delete!</b> * value <b>=&gt;</b> %</p>

      <blockquote>
        Removes the given value from the set.
      </blockquote>

      <p><i>procedure:</i> <b>*-union</b> * sets ... <b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-union!</b> * sets ... <b>=&gt;</b>
      %</p>

      <blockquote>
        Performs set union of the input set (first argument) with
        zero or more other sets. The resulting set contains the
        values of all input sets. The sets are unioned in pairwise
        fashion from left to right.
      </blockquote>

      <p><i>procedure:</i> <b>*-intersection</b> * sets ...
      <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-intersection!</b> * sets ...
      <b>=&gt;</b> %</p>

      <blockquote>
        Performs set intersection of the input set (first argument)
        with zero or more other sets. The resulting set contains
        the values common to all input sets. The sets are
        intersected in pairwise fashion from left to right.
      </blockquote>

      <p><i>procedure:</i> <b>*-difference</b> * sets ...
      <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-difference!</b> * sets ...
      <b>=&gt;</b> %</p>

      <blockquote>
        Performs set difference between the first input set and the
        union of all subsequent sets. The resulting set contains
        the values of the input set which appear in no subsequent
        set. Conceptually, the sets are subtracted from left to
        right in pairwise fashion.
      </blockquote>

      <p><i>procedure:</i> <b>*-symmetric-difference</b> * set
      <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-symmetric-difference!</b> * set
      <b>=&gt;</b> %</p>

      <blockquote>
        Performs set symmetric difference (also known as xor)
        between the two input sets. The resulting set contains the
        values of the input sets which are not in both sets. This
        operator is equivalent to <tt>(*-difference (*-union * set)
        (*-insersection * set))</tt>.
      </blockquote>

      <p><i>procedure:</i> <b>*-add-from</b> * bag <b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-add-from!</b> * bag <b>=&gt;</b> %</p>

      <blockquote>
        Adds all the values in the given bag to the input set.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-from</b> * bag <b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-delete-from!</b> * bag <b>=&gt;</b>
      %</p>

      <blockquote>
        Removes all the values in the given bag from the input set.
      </blockquote>

      <h3><a name="sequenceprocs">Sequences</a></h3>

      <p><i>procedure:</i> <b>sequence?</b> value <b>=&gt;</b>
      boolean</p>

      <blockquote>
        Returns a non-false value if the provided value is a
        sequence.
      </blockquote>

      <p><i>procedure:</i> <b>*-ref</b> * integer [absence-thunk]
      <b>=&gt;</b> value</p>

      <blockquote>
        Returns the value stored in the input sequence at the exact
        integer index provided. If the index is outside the range
        of the sequence, <tt>absence-thunk</tt> is invoked if
        present and its value returned instead. It is an error if
        the index is out of range and no absence-thunk is provided.
      </blockquote>

      <p><i>procedure:</i> <b>*-get-left</b> *
      [absence-thunk]<b>=&gt;</b> value</p>

      <blockquote>
        Returns the value at index 0 in the collection. If the
        sequence is empty, <tt>absence-thunk</tt> is invoked if
        present and its value returned, otherwise <tt>#f</tt> is
        returned.
      </blockquote>

      <p><i>procedure:</i> <b>*-get-right</b> *
      [absence-thunk]<b>=&gt;</b> value</p>

      <blockquote>
        Returns the value at index <tt>(- (sequence-size *) 1)</tt>
        in the collection. If the sequence is empty,
        <tt>absence-thunk</tt> is invoked if present and its value
        returned, otherwise <tt>#f</tt> is returned.
      </blockquote>

      <p><i>procedure:</i> <b>*-insert-right</b> *
      value<b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-insert-right!</b> * value<b>=&gt;</b>
      %</p>

      <blockquote>
        Adds a value to the end of the sequence.
      </blockquote>

      <p><i>procedure:</i> <b>*-set</b> * integer value
      <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-set!</b> * integer value <b>=&gt;</b>
      %</p>

      <blockquote>
        Replaces the value stored in the input sequence at the
        exact integer index provided with the given value. It is an
        error to reference an index outside the range of the
        sequence. It is recommended that the return value of this
        function be the previous value stored at the given index.
      </blockquote>

      <p><i>procedure:</i> <b>*-add</b> * value <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-add!</b> * value <b>=&gt;</b> %</p>

      <blockquote>
        Adds the given value to the end of the input sequence.
      </blockquote>

      <p><i>procedure:</i> <b>*-copy</b> * [start [end]]
      <b>=&gt;</b> %</p>

      <blockquote>
        Creates a new sequence whose type and contents are the same
        as the input sequence passed as an operand, but which is
        distinct enough in storage that the new sequence cannot be
        affected by modifications to the input sequence and vice
        versa. <tt>start</tt> and <tt>end</tt> are optional exact
        integer arguments. If start is provided the new sequence
        will contain the values of the input sequence starting from
        that offset and continuing to the end of the input
        sequence. If start and end are provided, the new sequence
        will contain the values from indices <tt>[start, end)</tt>.
        In either case the selected values appear in the new
        sequence from index 0.<br>
        This copy is <i>shallow</i>, that is, values are copied to
        the new sequence in a way that preserves object identity.
      </blockquote>

      <h3><a name="flexsequenceprocs">Flexible Sequences</a></h3>

      <p><i>procedure:</i> <b>flexible-sequence?</b> value
      <b>=&gt;</b> boolean</p>

      <blockquote>
        Returns a non-false value if the provided value is a
        flexible sequence.
      </blockquote>

      <p><i>procedure:</i> <b>*-insert</b> * index value
      <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-insert!</b> * index value <b>=&gt;</b>
      %</p>

      <blockquote>
        Inserts the provided value at the given index in the
        flexible sequence. If index is not equal to the
        <tt>collection-size</tt> of the sequence, this will result
        in the current value at index and subsequent values'
        indices to increase by one.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-at</b> * index <b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-delete-at!</b> * index <b>=&gt;</b>
      %</p>

      <blockquote>
        Deletes the current value at the given index in the
        flexible sequence. If index is not equal to the element at
        index <tt>(- (collection-size *) 1)</tt> of the sequence,
        this will result in the subsequent values' indices to
        decrease by one, filling the newly created gap.
      </blockquote>

      <p><i>procedure:</i> <b>*-insert-left</b> * value<b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-insert-left!</b> * value<b>=&gt;</b>
      %</p>

      <blockquote>
        Inserts a value into the flexible sequence at position 0.
      </blockquote>

      <p><i>procedure:</i> <b>*-insert-right</b> *
      value<b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-insert-right!</b> * value<b>=&gt;</b>
      %</p>

      <blockquote>
        Inserts a value into the flexible sequence at position
        <tt>(collection-size seq)</tt>.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-left</b> * <b>=&gt;</b> %
      value<br>
      <i>procedure:</i> <b>*-delete-left!</b> * <b>=&gt;</b> %
      value</p>

      <blockquote>
        Removes the value at position 0 in the flexible sequence,
        returning two values, the updated collection and the value
        removed.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-right</b> * <b>=&gt;</b> %
      value<br>
      <i>procedure:</i> <b>*-delete-right!</b> * <b>=&gt;</b> %
      value</p>

      <blockquote>
        Removes the value at position <tt>(-
        (flexible-sequence-size *) 1)</tt>, returning two values,
        the updated collection and the value removed.
      </blockquote>

      <h3><a name="mapprocs">Maps</a></h3>

      <p><i>procedure:</i> <b>map?</b> value <b>=&gt;</b>
      boolean</p>

      <blockquote>
        Returns a non-false value if the provided value is a map.
      </blockquote>

      <p><i>procedure:</i> <b>%</b> pair ... <b>=&gt;</b> %</p>

      <blockquote>
        Constructs a % map with zero or more bindings provided as
        its initial values. Each operand (after an equivalence
        and/or ordering function if present) to a map constructor
        must be a Scheme pair whose car is the new key and whose
        cdr is the value to which the key will map. If two mappings
        are provided with the same key, it is undefined which will
        remain in the map.
      </blockquote>

      <p><i>procedure:</i> <b>*-equivalence-function</b> *
      <b>=&gt;</b> procedure</p>

      <blockquote>
        Returns the value equivalence function for the input map.
      </blockquote>

      <p><i>procedure:</i> <b>*-key-equivalence-function</b> *
      <b>=&gt;</b> procedure</p>

      <blockquote>
        Returns the key equivalence function for the input map.
      </blockquote>

      <p><i>procedure:</i> <b>*-contains-key?</b> * key
      <b>=&gt;</b> boolean</p>

      <blockquote>
        Returns a non-false value if the input map has an entry for
        the given key, or false if it does not.
      </blockquote>

      <p><i>procedure:</i> <b>*-keys-&gt;list</b> * <b>=&gt;</b>
      list</p>

      <blockquote>
        Returns a newly allocated list containing the keys of the
        map. This can be done trivially with enumeration, but this
        procedure is provided if an implementation can more
        efficiently perform this operation directly. If the map is
        ordered, the list must contain the keys of the collection
        in the same order as a left key enumeration.
      </blockquote>

      <p><i>procedure:</i> <b>*-get</b> * key [absence-thunk]
      <b>=&gt;</b> value</p>

      <blockquote>
        Retrieves the value mapped by the given key. If no such
        mapping exists, <tt>absence-thunk</tt> is invoked if
        present and its value returned, otherwise <tt>#f</tt> is
        returned.
      </blockquote>

      <p><i>procedure:</i> <b>*-put</b> * key value
      [absence-thunk]<b>=&gt;</b> % value<br>
      <i>procedure:</i> <b>*-put!</b> * key value
      [absence-thunk]<b>=&gt;</b> % value</p>

      <blockquote>
        Replaces the previous mapping from the given key with a
        mapping from the same key to the provided value. The
        updated map is returned as the first value. If no previous
        mapping existed for the given key and
        <tt>absence-thunk</tt> provided, it is invoked and its
        value is returned as the second return value. If not
        provided, the second value is <tt>#f</tt>.<br>
        If a previous mapping existed, the value of the replaced
        mapping is returned as the second value.
      </blockquote>

      <p><i>procedure:</i> <b>*-update</b> * key func
      [absence-thunk] <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-update!</b> * key func [absence-thunk]
      <b>=&gt;</b> %</p>

      <blockquote>
        Updates the value of the mapping from the provided key
        <tt>key</tt> to the results of applying the single argument
        function <tt>func</tt> to the previous value. If no
        previous mapping existed, <tt>absence-thunk</tt> is invoked
        if present and its value passed to <tt>func</tt> otherwise
        <tt>#f</tt> is passed.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete</b> * key <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-delete!</b> * key <b>=&gt;</b> %</p>

      <blockquote>
        Removes an existing mapping for the given key. If no
        previous mapping existed, this call does nothing.
      </blockquote>

      <p><i>procedure:</i> <b>*-delete-from</b> * bag <b>=&gt;</b>
      %<br>
      <i>procedure:</i> <b>*-delete-from!</b> * bag <b>=&gt;</b>
      %</p>

      <blockquote>
        Removes all mappings from keys found in the given bag,
        returning the updated map.
      </blockquote>

      <p><i>procedure:</i> <b>*-add-from</b> * source-map
      <b>=&gt;</b> %<br>
      <i>procedure:</i> <b>*-add-from!</b> * source-map
      <b>=&gt;</b> %</p>

      <blockquote>
        Adds all the mappings in the source map to the input map.
        If a mapping exists in the source map and the input map,
        the mapping from the source will replace that of the
        destination.
      </blockquote><!--
              <h3>
                <a name="dictprocs">Dictionaries</a>
              </h3>
                <p>
                  <i>procedure:</i> <b>dictionary?</b> value <b>=&gt;</b>
                  boolean
                </p>
                <blockquote>
                  Returns a non-false value if the provided value is a
                  dictionary.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>%</b> pair ... <b>=&gt;</b> %
                </p>
                <blockquote>
                  Constructs a % dictionary with zero or more
                  bindings provided as its initial values. 
                  Each operand (after an equivalence and/or ordering function 
                  if present) to a dictionary constructor must be a Scheme pair
                  whose car is the new key and whose cdr is the value to which
                  the key will map.  Multiple values mapped from a single
                  key are added as several pairs, one for each value, with
                  the same key.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-key-count</b> dict key <b>=&gt;</b> exact integer
                </p>
                <blockquote>
                  Similar to <tt>*-count</tt>, but counts the number of times
                  the given key occurs in the dictionary (or, put another
                  way, the number of values the given key maps to), returning
                  that count as an integer.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-keys-&gt;list</b> dictionary
                  <b>=&gt;</b> list
                </p>
                <blockquote>
                  Returns a newly allocated list containing the keys of
                  the dictionary. This can be done trivially with
                  enumeration, but this procedure is provided if an
                  implementation can more efficiently perform this
                  operation directly. If the collection is ordered, the
                  list must contain the keys of the collection in the
                  same order as a left key enumeration.  If a key maps to
                  multiple values, the key will occur once for each value it
                  binds to.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-get</b> dictionary key [absence-thunk]
                  <b>=&gt;</b> value
                </p>
                <blockquote>
                  Retrieves one value of the mapping for the given key.
                  If no such mapping exists, <tt>absence-thunk</tt> is
                  invoked if present and its value returned,  
                  otherwise <tt>#f</tt> is returned.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-get-all</b> dictionary key [absence-thunk]
                  <b>=&gt;</b> bag
                </p>
                <blockquote>
                  Retrieves all values mapped from the given key as a bag.
                  If no mappings exist, <tt>absence-thunk</tt> is
                  invoked if present and its value returned,  
                  otherwise <tt>#f</tt> is returned.  It is an error
                  to modify the resulting bag through side-effects, and 
                  may have unpredictable behavior regarding the 
                  source map if the bag is updated with a linear update function.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-add</b> dictionary key
                  value <b>=&gt;</b> % <br>
                   <i>procedure:</i> <b>*-add!</b> dictionary
                  key value <b>=&gt;</b> % 
                </p>
                <blockquote>
                  Adds a mapping for the given key or value,
                  returning the updated dictionary.  
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-put</b> dictionary key
                  value [absence-thunk]<b>=&gt;</b> % value <br>
                   <i>procedure:</i> <b>*-put!</b> dictionary
                  key value [absence-thunk]<b>=&gt;</b> % value 
                </p>
                <blockquote>
                  Replaces one previous mapping from the given key
                  with a mapping from the same key to the provided value.
                  The updated dictionary is returned as the first value.
                  If no previous mapping existed for the given key and
                  <tt>absence-thunk</tt> provided, it is is invoked and 
                  its value is as the second return value.  If not provided,
                  the second value is <tt>#f</tt>.  <br>
                  If a previous mapping existed, the value of the replaced
                  mapping is returned as the second value.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-replace-all</b> dictionary key
                  value ...<b>=&gt;</b> %<br>
                   <i>procedure:</i> <b>*-replace-all!</b> dictionary
                  key value ...<b>=&gt;</b> %
                </p>
                <blockquote>
                  Replaces any previous mappings from the given key
                  with mappings from the same key to the provided zero
                  or more values.  If no values are provided, this call 
                  is equivalent to <tt>*-delete-all</tt>.
                  The updated dictionary is returned.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-update</b> dictionary key func
                  [absence-thunk] <b>=&gt;</b> %<br>
                   <i>procedure:</i> <b>*-update!</b> dictionary key func
                  [absence-thunk] <b>=&gt;</b> %
                </p>
                <blockquote>
                  Updates the value of an unspecified dictionary mapping
                  from the provided key
                  <tt>key</tt> to the result of applying the single
                  argument function <tt>func</tt> to the previous value.
                  If no previous mapping existed, <tt>absence-thunk</tt> is
                  invoked if present and its value passed to <tt>func</tt>
                  otherwise <tt>#f</tt> is passed.  
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-update-all</b> dictionary key func
                  [absence-thunk] <b>=&gt;</b> %<br>
                   <i>procedure:</i> <b>*-update-all!</b> dictionary key func
                  [absence-thunk] <b>=&gt;</b> %
                </p>
                <blockquote>
                  Updates the value of zero more more mappings from the
                  given key to any number of values.  Behaves as
                  <tt>*-update[!]</tt> above, except the update function may
                  be called as many times as there are values mapped by the
                  key, updating each one.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-delete</b> dictionary key [value]
                  <b>=&gt;</b> %<br>
                   <i>procedure:</i> <b>*-delete!</b> dictionary key [value]
                  <b>=&gt;</b> %
                </p>
                <blockquote>
                  Removes an existing mapping for the given key.
                  If the optional <tt>value</tt> argument is provided,
                  the specific mapping from the given key to the value 
                  is deleted.  Without it, any one mapping for the given key 
                  is deleted.  If no previous mapping existed, this
                  call makes does nothing.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-delete-all</b> dictionary key
                  <b>=&gt;</b> %<br>
                   <i>procedure:</i> <b>*-delete-all!</b> dictionary
                  key <b>=&gt;</b> %
                </p>
                <blockquote>
                  Removes all existing mappings for the given key. If
                  that mapping does not exist, this call makes
                  no changes. This procedure is equivalent to 
                  <tt>*-delete</tt> if the dictionary supports
                  only one binding per key.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-delete-from</b> dictionary bag
                  <b>=&gt;</b> %<br>
                   <i>procedure:</i> <b>*-delete-from!</b> dictionary
                  bag <b>=&gt;</b> %
                </p>
                <blockquote>
                  Removes one mapping from the dictionary for each
                  key present in the given bag.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-delete-all-from</b> dictionary bag
                  <b>=&gt;</b> %<br>
                   <i>procedure:</i> <b>*-delete-all-from!</b> dictionary
                  bag <b>=&gt;</b> %
                </p>
                <blockquote>
                  Removes all mappings from the dictionary from
                  keys present in the given bag.
                </blockquote>
                <p>
                  <i>procedure:</i> <b>*-add-all</b> dest-dict
                  source-dict <b>=&gt;</b> %<br>
                   <i>procedure:</i> <b>*-add-all!</b> dest-dict
                  source-dict <b>=&gt;</b> %
                </p>
                <blockquote>
                  Adds all the mappings in the source dictionary to the
                  destination dictionary. 
                </blockquote>-->
              </blockquote> 
             
      <h2><a name="schemecolls">Scheme Collections</a></h2>

      <p>This SRFI additionally specifies a Collections API based
      around the Scheme list, the association list, the vector, and
      string types. These types are compatible with those from
      R5RS. Where procedures from this SRFI intersect with those
      from R5RS, the SRFI-44 procedures are extensions of their
      standard counterparts. It is intended that the collection
      types provided here be usable both by the collections
      operators and other standard Scheme programs.</p>

      <blockquote>
        <h4><a name="lists">Lists</a></h4>

        <p>Scheme List collections are flexible sequences. In the
        reference implementation provided by this SRFI, lists have
        an unstable enumeration.</p>

        <p><i>procedure:</i> <b>make-list</b> [size [default]]
        <b>=&gt;</b> list</p>

        <blockquote>
          Creates a new list. If size is provided, it will start
          out with size instances of the value given as default. If
          default is not provided, the contents of the list are
          undefined.
        </blockquote><i>procedure:</i> <b>list</b> value ... =&gt;
        list<br>
        <br>

        <p><i>procedure:</i> <b>list-fold-left</b> list
        fold-function seeds ... <b>=&gt;</b> seeds ...<br>
        <i>procedure:</i> <b>list-fold-right</b> list fold-function
        seeds ... <b>=&gt;</b> seeds ...</p>

        <p><i>procedure:</i> <b>list-equivalence-function</b> list
        <b>=&gt;</b> procedure</p>

        <p><i>procedure:</i> <b>list-copy</b> list [start [end]]
        <b>=&gt;</b> list<br>
        <i>procedure:</i> <b>list-&gt;list</b> list <b>=&gt;</b>
        list</p>

        <p><i>procedure:</i> <b>list?</b> value <b>=&gt;</b>
        boolean<br>
        <i>procedure:</i> <b>list-size</b> list <b>=&gt;</b> exact
        integer<br>
        <i>procedure:</i> <b>list-empty?</b> list <b>=&gt;</b>
        boolean</p>

        <p><i>procedure:</i> <b>list-contains?</b> list value
        <b>=&gt;</b> boolean</p>

        <p><i>procedure:</i> <b>list-ref</b> list integer
        [absence-thunk] <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>list-get-any</b> list [absence-thunk]
        <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>list-get-left</b> list [absence-thunk]
        <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>list-get-right</b> list
        [absence-thunk] <b>=&gt;</b> value</p>

        <p><i>procedure:</i> <b>list-count</b> list value =&gt;
        exact integer</p>

        <p><i>procedure:</i> <b>list=</b> elt= lists ... =&gt;
        boolean</p>

        <p><i>procedure:</i> <b>list-add</b> list value =&gt;
        list<br>
        <i>procedure:</i> <b>list-add!</b> list value =&gt;
        list</p>

        <p><i>procedure:</i> <b>list-set</b> list integer value
        =&gt; list<br>
        <i>procedure:</i> <b>list-set!</b> list integer value =&gt;
        list</p>

        <p><i>procedure:</i> <b>list-insert-left</b> list value
        <b>=&gt;</b> list<br>
        <i>procedure:</i> <b>list-insert-left!</b> list value
        <b>=&gt;</b> list<br>
        <i>procedure:</i> <b>list-insert-right</b> list value
        <b>=&gt;</b> list<br>
        <i>procedure:</i> <b>list-insert-right!</b> list value
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>list-delete</b> list value =&gt;
        list<br>
        <i>procedure:</i> <b>list-delete!</b> list value
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>list-delete-left</b> list
        <b>=&gt;</b> list value<br>
        <i>procedure:</i> <b>list-delete-left!</b> list
        <b>=&gt;</b> list value<br>
        <i>procedure:</i> <b>list-delete-right</b> list
        <b>=&gt;</b> list value<br>
        <i>procedure:</i> <b>list-delete-right!</b> list
        <b>=&gt;</b> list value</p>

        <p><i>procedure:</i> <b>list-delete-all</b> list value
        <b>=&gt;</b> list<br>
        <i>procedure:</i> <b>list-delete-all!</b> list value
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>list-add-from</b> list bag =&gt;
        list<br>
        <i>procedure:</i> <b>list-add-from!</b> list bag
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>list-delete-from</b> list bag =&gt;
        list<br>
        <i>procedure:</i> <b>list-delete-from!</b> list bag
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>list-delete-all-from</b> list bag
        <b>=&gt;</b> list<br>
        <i>procedure:</i> <b>list-delete-all-from!</b> list bag
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>list-clear</b> list <b>=&gt;</b>
        list<br>
        <i>procedure:</i> <b>list-clear!</b> list <b>=&gt;</b>
        list</p>

        <p><i>procedure:</i> <b>list-insert</b> list index value
        =&gt; list<br>
        <i>procedure:</i> <b>list-insert!</b> list index value
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>list-delete-at</b> list index =&gt;
        list<br>
        <i>procedure:</i> <b>list-delete-at!</b> list index
        <b>=&gt;</b> list</p>

        <h4><a name="alists">Association List Maps</a></h4>Scheme
        association lists implement a superset of the Map
        functionality (they may store more than one key/value pair
        with the same key). The operations below operate on alists
        as maps, enforcing a single instance of each key. Because a
        future SRFI may specify M:N mappings (dictionaries), we
        call the alist version of an SRFI-44 map an "alist-map". In
        the reference implementation provided by this SRFI, the
        alist-map has an unstable enumeration.<br>
        <br>

        <p><i>procedure:</i> <b>make-alist-map</b>
        [equivalence-function] <b>=&gt;</b> alist-map<br>
        <i>procedure:</i> <b>alist-map</b> [equivalence-function]
        (key . value) ... <b>=&gt;</b> alist-map</p>

        <p><i>procedure:</i> <b>alist-map-fold-left</b> alist-map
        fold-function seeds ... <b>=&gt;</b> seeds ...<br>
        <i>procedure:</i> <b>alist-map-fold-right</b> alist-map
        fold-function seeds ... <b>=&gt;</b> seeds ...<br>
        <i>procedure:</i> <b>alist-map-fold-keys-left</b> alist-map
        fold-function seeds ... <b>=&gt;</b> seeds ...<br>
        <i>procedure:</i> <b>alist-map-fold-keys-right</b> alist-map
        fold-function seeds ... <b>=&gt;</b> seeds ...</p>

        <p><i>procedure:</i> <b>alist-map-equivalence-function</b>
        alist-map <b>=&gt;</b> procedure<br>
        <i>procedure:</i> <b>alist-map-key-equivalence-function</b>
        alist-map <b>=&gt;</b> procedure</p>

        <p><i>procedure:</i> <b>alist-map-count</b> alist-map value
        <b>=&gt;</b> exact integer<br>
        <i>procedure:</i> <b>alist-map-key-count</b> alist-map
        value <b>=&gt;</b> exact integer<br>
        <i>procedure:</i> <b>alist-map-contains-key?</b> alist-map
        value <b>=&gt;</b> boolean<br>
        <i>procedure:</i> <b>alist-map-size</b> alist-map
        <b>=&gt;</b> exact integer</p>

        <p><i>procedure:</i> <b>alist-map-copy</b> alist-map
        <b>=&gt;</b> alist-map<br>
        <i>procedure:</i> <b>alist-map-&gt;list</b> alist-map
        <b>=&gt;</b> list<br>
        <i>procedure:</i> <b>alist-map-keys-&gt;list</b> alist-map
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>alist-map?</b> value <b>=&gt;</b>
        boolean</p>

        <p><i>procedure:</i> <b>alist-map=</b> elt= alist-maps ...
        <b>=&gt;</b> boolean</p>

        <p><i>procedure:</i> <b>alist-map-get</b> alist-map key
        <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>alist-map-get-all</b> alist-map key
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>alist-map-put</b> alist-map key
        value <b>=&gt;</b> alist-map value<br>
        <i>procedure:</i> <b>alist-map-put!</b> alist-map key value
        <b>=&gt;</b> alist-map value<br>
        <i>procedure:</i> <b>alist-map-replace-all</b> alist-map
        key value ... <b>=&gt;</b> alist-map<br>
        <i>procedure:</i> <b>alist-map-replace-all!</b> alist-map
        key value ... <b>=&gt;</b> alist-map</p>

        <p><i>procedure:</i> <b>alist-map-update</b> alist-map key
        func [absence-thunk]=&gt; alist-map<br>
        <i>procedure:</i> <b>alist-map-update!</b> alist-map key
        func [absence-thunk]=&gt; alist-map<br>
        <i>procedure:</i> <b>alist-map-update-all</b> alist-map key
        func [absence-thunk]=&gt; alist-map<br>
        <i>procedure:</i> <b>alist-map-update-all!</b> alist-map
        key func [absence-thunk]=&gt; alist-map</p>

        <p><i>procedure:</i> <b>alist-map-delete</b> alist-map key
        =&gt; alist-map<br>
        <i>procedure:</i> <b>alist-map-delete!</b> alist-map key
        <b>=&gt;</b> alist-map</p>

        <p><i>procedure:</i> <b>alist-map-delete-all</b> alist-map
        key <b>=&gt;</b> alist-map<br>
        <i>procedure:</i> <b>alist-map-delete-all!</b> alist-map
        key <b>=&gt;</b> alist-map</p>

        <p><i>procedure:</i> <b>alist-map-delete-from</b> alist-map
        bag <b>=&gt;</b> alist-map<br>
        <i>procedure:</i> <b>alist-map-delete-from!</b> alist-map
        bag <b>=&gt;</b> alist-map</p>

        <p><i>procedure:</i> <b>alist-map-delete-all-from</b>
        alist-map bag <b>=&gt;</b> alist-map<br>
        <i>procedure:</i> <b>alist-map-delete-all-from!</b>
        alist-map bag <b>=&gt;</b> alist-map</p>

        <p><i>procedure:</i> <b>alist-map-clear</b> alist-map
        <b>=&gt;</b> alist-map<br>
        <i>procedure:</i> <b>alist-map-clear!</b> alist-map
        <b>=&gt;</b> alist-map</p>

        <p><i>procedure:</i> <b>alist-map-add-from</b> alist-map
        dict =&gt; alist-map<br>
        <i>procedure:</i> <b>alist-map-add-from!</b> alist-map dict
        <b>=&gt;</b> alist-map</p>

        <h4><a name="vectors">Vectors</a></h4>

        <p>Scheme Vectors are purely mutable limited sequences. In
        the reference implementation provided by this SRFI, vectors
        have an unstable enumeration. The functional update
        procedures of vectors likely require a vector clone, and
        would therefore impose an efficiency penalty over the
        side-effecting update procedures.</p>

        <p><i>procedure:</i> <b>make-vector</b> size [default]
        <b>=&gt;</b> vector</p>

        <blockquote>
          Creates a new vector with the provided size. If default
          is not provided, the contents of the vector are
          undefined.
        </blockquote><i>procedure:</i> <b>vector</b> value ...
        <b>=&gt;</b> vector<br>
        <br>

        <p><i>procedure:</i> <b>vector-fold-left</b> vector
        fold-function seeds ... <b>=&gt;</b> seeds ...<br>
        <i>procedure:</i> <b>vector-fold-right</b> vector
        fold-function seeds ... <b>=&gt;</b> seeds ...</p>

        <p><i>procedure:</i> <b>vector-equivalence-function</b>
        vector <b>=&gt;</b> procedure</p>

        <p><i>procedure:</i> <b>vector-copy</b> vector [start
        [end]] <b>=&gt;</b> vector<br>
        <i>procedure:</i> <b>vector-&gt;list</b> vector
        <b>=&gt;</b> list</p>

        <p><i>procedure:</i> <b>vector?</b> value <b>=&gt;</b>
        boolean<br>
        <i>procedure:</i> <b>vector-size</b> vector <b>=&gt;</b>
        exact integer<br>
        <i>procedure:</i> <b>vector-empty?</b> vector <b>=&gt;</b>
        boolean</p>

        <p><i>procedure:</i> <b>vector-contains?</b> vector value
        =&gt; boolean</p>

        <p><i>procedure:</i> <b>vector-count</b> vector value
        <b>=&gt;</b> exact integer</p>

        <p><i>procedure:</i> <b>vector-ref</b> vector index
        [absence-thunk] <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>vector-get-any</b> vector
        [absence-thunk] <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>vector-get-left</b> vector
        [absence-thunk] <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>vector-get-right</b> vector
        [absence-thunk] <b>=&gt;</b> value</p>

        <p><i>procedure:</i> <b>vector-set</b> vector index value
        <b>=&gt;</b> vector<br>
        <i>procedure:</i> <b>vector-set!</b> vector index value
        <b>=&gt;</b> vector</p>

        <p><i>procedure:</i> <b>vector=</b> elt= vectors ...
        <b>=&gt;</b> boolean</p>

        <h4><a name="strings">Strings</a></h4>

        <p>Scheme strings are purely mutable limited homogeneous
        sequences which can only store characters. In the reference
        implementation provided by this SRFI, strings have an
        unstable enumeration. The functional update procedures of
        strings likely require a vector clone, and would therefor
        impose an efficiency penalty over the side-effecting update
        procedures.</p>

        <p><i>procedure:</i> <b>make-string</b> size
        [default-character] <b>=&gt;</b> string<br>
        <i>procedure:</i> <b>string</b> character ... =&gt;
        string</p>

        <p><i>procedure:</i> <b>string-fold-left</b> string
        fold-function seeds ... <b>=&gt;</b> seeds ...<br>
        <i>procedure:</i> <b>string-fold-right</b> string
        fold-function seeds ... <b>=&gt;</b> seeds ...</p>

        <p><i>procedure:</i> <b>string-equivalence-function</b>
        string <b>=&gt;</b> procedure</p>

        <p><i>procedure:</i> <b>string-copy</b> string [start
        [end]]=&gt; string<br>
        <i>procedure:</i> <b>string-&gt;list</b> string =&gt;
        list</p>

        <p><i>procedure:</i> <b>string-size</b> string <b>=&gt;</b>
        exact integer<br>
        <i>procedure:</i> <b>string-empty?</b> string <b>=&gt;</b>
        boolean</p>

        <p><i>procedure:</i> <b>string?</b> value <b>=&gt;</b>
        boolean</p>

        <p><i>procedure:</i> <b>string-contains?</b> string
        character <b>=&gt;</b> boolean</p>

        <p><i>procedure:</i> <b>string-count</b> string character
        <b>=&gt;</b> exact integer</p>

        <p><i>procedure:</i> <b>string-ref</b> string index
        [absence-thunk] <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>string-get-any</b> string
        [absence-thunk] <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>string-get-left</b> string
        [absence-thunk] <b>=&gt;</b> value<br>
        <i>procedure:</i> <b>string-get-right</b> string
        [absence-thunk] <b>=&gt;</b> value</p>

        <p><i>procedure:</i> <b>string-set</b> string index
        character <b>=&gt;</b> string<br>
        <i>procedure:</i> <b>string-set!</b> string index character
        <b>=&gt;</b> string</p>

        <p><i>procedure:</i> <b>string=</b> elt= strings ...
        <b>=&gt;</b> boolean</p>
      </blockquote>
    </blockquote>
    
    <H1><a name="compat">Compatibility</a></H1>

    <p>Some of the names defined in this SRFI uses the same or
    similar name in existing SRFIs or implementations. Some of them
    are defined so that they are extension of the existing
    practice, and some of them have incompatibilities.</p>

    <blockquote>
      <h2><a name="r5rsext">Extensions to R5RS</a></h2>

      <p>R5RS doesn't specify the return value of
      <tt>string-set!</tt> and <tt>vector-set!</tt>. This SRFI
      specifies them to return the passed collection.
      <tt>string-ref, vector-ref</tt> and <tt>list-ref</tt> are
      extended to take an optional argument, the absence-thunk.</p>

      <h2><a name="othersrfis">Relation to other SRFIs</a></h2>

      <p><tt>string=</tt> has different interface from
      <tt>string=</tt> in SRFI-13, which has the following API:</p>
      <pre>
     (string= string1 string2 [start1 end1 start2 end2])
</pre>

      <p>If the implementation wishes to support both SRFIs, it may
      dispatch by its argument types. Note that SRFI-13's
      <tt>string=</tt>, while having the naming convention also
      used by SRFIs 1 and 43, has a different purpose: it is rather
      an extension of R5RS's <tt>string=?</tt> (note the question
      mark) with a modified name.</p>

      <p><tt>string-copy</tt> is a superset, while
      <tt>string-count</tt> is a subset of the same operators from
      SRFI-13.</p>

      <p><tt>*-count</tt> from this SRFI differs from
      <tt>count</tt> in SRFI-1. This SRFI specifies no SRFI-1
      compatible count as it could not be significantly more
      efficient than a fold.</p>

      <p><tt>string-contains?</tt> has a similar name to
      <tt>string-contains</tt> from SRFI-13, but the latter looks
      for substring match, instead of element-wise match.</p>

      <p>Both arguments of <tt>make-list</tt> in this SRFI are
      optional. Only the last argument in SRFI-1 is optional.</p>

      <h2><a name="impls">Relation to Scheme
      implementations</a></h2>

      <p>Some implementations (e.g. PLT) use absence-thunk to give
      a default value in ?-ref or ?-get API. Other implementations
      (e.g. Chicken, STk, Gauche) instead allow an optional value
      to specify a default value. This SRFI takes the thunk
      approach due to its additional flexiblility not only to
      produce a default value, but to do so through an arbitrary
      computation. There are various other extensions and
      incompatibilities sprinkled among implementations. For
      example, Gauche has extended versions of string-ref,
      vector-ref and list-ref, and has a string-size operator which
      returns the number of bytes a multi-byte string occupies.</p>
    </blockquote>

    <h1><a name="implementation">Implementation</a></h1>

    <p>This SRFI behaves more as a meta-SRFI for future SRFIs to
    define concrete collection types. However, a reference
    implementation for the collections wrapper around the common
    Scheme types is provided in the archive <a href=
    "http://srfi.schemers.org/srfi-44/srfi-44.tar.gz">srfi-44.tar.gz</a>.
    It requires SRFI's 1 (list-lib), 23 (error), and the Tiny-CLOS
    portable object system to provide type dispatch.</p>

    <h1><a name="futurework">Future Work</a></h1>

    <p>This SRFI does not specify any concrete collections beyond
    those which already exist in Scheme. Obvious future work
    involves specifying a useful set of collections for modern
    Scheme programming.</p>

    <p>Additionally, sorting and searching are deliberately left
    out of this SRFI to avoid complexity. Sorting and searching
    would be useful for a great number of applications.
    Resurrecting SRFI-32 and reforming it in the context of this
    SRFI may be a useful endeavour.</p>

    <p>Earlier drafts of this SRFI included not only the M:1 Map
    collection, but an M:N Dictionary collection which could map a
    key to numerous values. This collection was removed because it
    was not clear that we knew what actually constituted an optimal
    interface for such a collection. The text of the specification
    at the time of its removal is included in this document, but
    commented out. It may make a good starting point for a
    Dictionary SRFI to build on this specification.</p>

    <p>Because this SRFI leaves the dispatch strategy open to
    implementers, it is impossible for a collection implementer to
    add a new collection to a system supporting this SRFI without
    knowledge of the mechanisms used. It may be worthwile to
    standardize an interface for adding collections to an SRFI-44
    compliant system that is independent of the dispatch
    system.</p>

    <p>Finally, some interest was shown in several extensions which
    allow for various other programming paradigms and in extensions
    which improve the programmer's ability to write very efficient
    code while remaining agnostic of collection type, at the
    expense of some simplicity. Rather than support all of these
    requests in this SRFI with limited study, it was decided to
    keep the SRFI simple and non-conflicting with these ideas.
    Future work may take up these issues and devote the proper time
    which they deserve.</p>

    <h1><a name="references">References</a></h1>

    <p>Much of this design is influenced by other languages
    collection interfaces. Below are links to other languages'
    collections interfaces, many of which contributed to design
    decisions.</p>

    <ul>
      <li><a href=
      "http://core.federated.com/~jim/dirm/interim-40.html">Dylan</a></li>

      <li><a href=
      "http://www.haskell.org/ghc/docs/edison/index.html">Edison
      (Library)</a></li>

      <li><a href=
      "http://www.ai.mit.edu/~jrb/goo/goo-v45.pdf">Goo</a></li>

      <li><a href=
      "http://java.sun.com/products/jdk/1.2/docs/guide/collections/">
      Java</a></li>

      <li><a href=
      "http://cscott.net/Projects/JUtil/jutil-latest/doc/">JUtil
      (Java)</a></li>

      <li><a href=
      "http://www.python.org/doc/current/lib/types.html">Python</a></li>

      <li><a href=
      "http://mucow.com/SqueakClassesRef.html#CollectionClasses">Smalltalk
      (Squeak)</a></li>
    </ul>
    <p>
      The generic enumerations protocol was championed by Oleg Kiselyov
      and his work on enumeration:
    </p>
    <ul>
      <li><a href="http://okmij.org/ftp/Scheme/enumerators-callcc.html">General ways to Traverse Collections</a> [Feb 2003]</li>
    </ul>

    <H1>Copyright</H1>

    <p>Copyright (C) Scott G. Miller (2003). All Rights
    Reserved.</p>

    <p>This document and translations of it may be copied and
    furnished to others, and derivative works that comment on or
    otherwise explain it or assist in its implementation may be
    prepared, copied, published and distributed, in whole or in
    part, without restriction of any kind, provided that the above
    copyright notice and this paragraph are included on all such
    copies and derivative works. However, this document itself may
    not be modified in any way, such as by removing the copyright
    notice or references to the Scheme Request For Implementation
    process or editors, except as needed for the purpose of
    developing SRFIs in which case the procedures for copyrights
    defined in the SRFI process must be followed, or as required to
    translate it into languages other than English.</p>

    <p>The limited permissions granted above are perpetual and will
    not be revoked by the authors or their successors or
    assigns.</p>

    <p>This document and the information contained herein is
    provided on an "AS IS" basis and THE AUTHOR AND THE SRFI
    EDITORS DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
    HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p>

    <hr>
    <address>Author: <a href="mailto:scgmille@freenetproject.org">Scott G. Miller</a></address>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">Francisco Solsona</a></address>
    <!-- Created: Tue Sep 29 19:20:08 EDT 1998 -->
    <!-- hhmts start --><!-- hhmts end -->
    Last modified: Wed Nov 19 15:51 CST 2003
  </blockquote>
</body>
</html>
