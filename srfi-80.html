<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>SRFI 80: Stream I/O</title>
</head>
<body>

<H1>Title</H1>

Stream I/O

<H1>Author</H1>

Michael Sperber

<H1>Status</H1>

This SRFI is currently in ``draft'' status.  For an explanation of
each status that a SRFI can hold, see
<A HREF="http://srfi.schemers.org/srfi-process.html">here</A>.  You can
access the discussion via <A HREF="mail-archive/maillist.html">the
archive of the mailing list</A>.

<UL>
<LI>Received: 2005-10-08
<LI>Draft: 2005-11-24
</UL>

<h1>Abstract</h1>

<p>This SRFI defines an I/O layer for lazy, mostly functional buffered streams.</p><p>The layer architecture is similar to the upper three layers of the I/O subsystem in <a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a>.</p><p>In particular, this layer provides</p><ul><li>buffered reading and writing</li><li>arbitrary lookahead</li><li>dynamic redirection of input or output</li><li>binary and text I/O, mixed if needed</li><li>translated data streams</li><li>the ability to create I/O streams from arbitrary readers and writers </li></ul><p>It builds on the Primitive I/O  layer specified in <a href="http://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</p><h1>Rationale</h1><p>The I/O subsystem in R5RS is too limited in many respects:  It only provides for text I/O, it only allows reading at the character and the datum level, and some of the primitives are mis-designed or underspecified.  As a result, almost every Scheme implementation has its own extensions to the I/O system, and rarely are two of these extensions compatible.</p><p>This SRFI is meant as one possible compelling replacement for the R5RS I/O subsystem.  As such, it is a completely new design, and it is not based on the extensions a particular existing Scheme system provides.  (In fact, it is probably, in its entirety, unlike what any existing Scheme system provides.)  Moreover, it is meant to be a substrate for further extensions which can be built on top of the subsystem via the interface described here.</p><p>The Port I/O layer specified in <a href="http://srfi.schemers.org/srfi-81/">SRFI 81 (Port I/O)</a> provides an alternative such replacement.  The Port I/O layer is closer to R5RS.  However, the Stream I/O layer is more powerful and more expressive in several ways.</p><p>The design of this SRFI is driven by the requirements mentioned in the abstract on the one hand, and on the excellent design of the I/O subsystem in the Standard ML Basis Library. The latter is also the reason why this SRFI is different from the extensions provided by any existing Scheme implementation, as none of them picked up on the Basis design, and because the Basis design seems superior to the extensions I have looked at.  (Among those I have looked at are Scheme 48, scsh, Gambit-C, and PLT Scheme.)</p><p>Note, however, that this SRFI differs from the SML Basis in several important respects, among them the handling of textual I/O streams, the ability to define translated streams, and the absence of any functionality related to non-blocking I/O.  The latter is more properly in the domain of a thread/event system; Concurrent ML shows that the SML Basis plays well with such a system, and I expect the same to hold true here.  The text encoding/translation functionality is different mainly because it plays to a different substrate for representing text (based on Unicode; see below) than Standard ML.</p><p>Like the Standard ML Basis I/O subsystem, the I/O system specified in this SRFI is not suitable for maximal-throughput I/O, chiefly because it does not re-use buffers.  However, I deemed the achievable performance as more than adequate for most applications---it seemed a small price to pay for the convenient programming model.</p><h1>Specification</h1><h2>Prerequisites</h2><p>This SRFI is meant for Scheme implementations with the following prerequisites:</p><ul><li><a href="http://srfi.schemers.org/srfi-34/">SRFI 34 (Exception Handling for Programs)</a></li><li><a href="http://srfi.schemers.org/srfi-35/">SRFI 35 (Conditions)</a></li><li><a href="http://srfi.schemers.org/srfi-74/">SRFI 74 (Octet-Addressed Binary Blocks)</a></li><li><a href="http://srfi.schemers.org/srfi-75/">SRFI 75 (R6RS Unicode data)</a></li><li><a href="http://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a></li></ul><h2>Unicode support</h2><p>This SRFI assumes that the <code>char</code> datatype in Scheme corresponds to Unicode scalar values.  This, in turn, means that strings are represented as vectors of scalar values. (Note that this is consistent with <a href="http://srfi.schemers.org/srfi-14/">SRFI 14 (Character-set library)</a> and <a href="http://srfi.schemers.org/srfi-75/">SRFI 75 (R6RS Unicode data)</a>.) It may be possible to make this SRFI work in an ASCII- or Latin-1-only system, but I have not made any special provisions to ensure this.</p><h2>Filenames</h2><p>Filenames in this SRFI are the same as in <a href="http://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</p><h2>General remarks</h2><p>For procedures that have no "natural" return value, this SRFI often uses the sentence</p><p><em>The return values are unspecified.</em></p><p>This means that number of return values  and the return values are unspecified.  However, the number of return values  is such that it is accepted by a continuation created by <code>begin</code>.  Specifically, on Scheme implementations where continuations created by <code>begin</code> accept an arbitrary number of arguments (this includes most implementations), it is suggested that the procedure return zero return values.</p><h2>Blobs</h2><p>The specification frequently refers to <i>blobs</i>.  These are as specified in <a href="http://srfi.schemers.org/srfi-74/">SRFI 74 (Octet-Addressed Binary Blocks)</a>.</p><h2>File options</h2><p>File options are as in <a href="http://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</p><h2>Buffer modes</h2><p>Each output stream has an associated <i>buffer mode</i> that defines when an output operation will flush the buffer associated with the output stream.  The possible buffer modes are <code>none</code> for no buffering, <code>line</code> for flushing upon newlines, and <code>block</code> for block-based buffering.</p><p>While this SRFI does not require buffer modes to form a distinct type, implementors are encouraged to make them a distinct type.</p><dl><dt><code>(buffer-mode </code><var>name</var><code>)</code> (syntax)</dt><dd><p><var>Name</var> must be one of the identifiers <code>none</code>, <code>line</code>, and <code>block</code>.  This returns a buffer-mode object denoting the associated buffer mode.  There is only one such object for each mode, so a program can compare them using <code>eq?</code>.</p></dd><dt><code>(buffer-mode? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is a buffer-mode object, <code>#f</code> otherwise.</p></dd></dl><h2>Text Transcoders</h2><p>Transcoders provide pre-packaged functionality for encoding and decoding text in some common encodings.  A <i>transcoder</i> is an opaque object encapsulating a specific text encoding.  This SRFI specifies how to obtain a transcoder given a text encoder/decoder (or <i>codec</i> for short) and a specified newline encoding.  Codecs are constructed by pairing up input and output stream translators.</p><dl><dt><code>(transcoder </code><code>(codec <var>codec</var>)</code> <code>(eol-style <var>eol-style</var>)</code><code>)</code> (syntax)</dt><dd><p>This constructs a transcoder object from a specified codec and a specified end-of-line style.  The <code>codec</code> and the <code>eol-style</code> clauses are both optional.  If present, <var>codec</var> and <var>eol-style</var>, must be expressions that evaluate to a codec and an eol-style object, respectively.  If not present, the codec defaults to "no codec" (corresponding to UTF-8), and the eol-style object defaults to the platform's standard EOL convention.</p><p>Any operands to a <code>transcoder</code> form that do not match the above syntax may be platform-specific extensions.  The implementation is free to ignore them, but must not signal an error.</p></dd><dt><code>(update-transcoder </code><var>old</var> <code>(codec <var>codec</var>)</code> <code>(eol-style <var>eol-style</var>)</code><code>)</code> (syntax)</dt><dd><p>This form returns a new transcoder object constructed from an old one, with the <code>codec</code> and <code>eol-style</code> fields replaced by the specified values.  (Again, the <code>codec</code> and the <code>eol-style</code> clauses are both optional.  Also, unrecognized operands can be ignored, but cannot signal an error.)</p></dd><dt><code>(eol-style </code><code>lf</code><code>)</code> (syntax)</dt><dt><code>(eol-style </code><code>crlf</code><code>)</code> (syntax)</dt><dt><code>(eol-style </code><code>cr</code><code>)</code> (syntax)</dt><dd><p>These forms evaluate to end-of-line-style objects - <code>lf</code> stands for using U+000A, <code>crlf</code> stands for using U+000D U+000A, and <code>cr</code> stands for using U+000D as end-of-line.</p></dd><dt><code>(make-codec </code><var>string</var> <var>translate-input</var> <var>translate-output</var> <var>initial-state</var><code>)</code></dt><dd><p>This constructs a codec object.  <var>String</var> must be a string naming the encoding.  <var>Translate-input</var> must be a translation procedure suitable for use by <a href="#make-translated-input-stream"><code>make-translated-input-stream</code></a>. <var>Translate-output</var> must be a translation procedure suitable for use by <a href="#make-translated-output-stream"><code>make-translated-output-stream</code></a>, and <var>initial-state</var> must be a suitable initial state.</p></dd><dt><code>latin-1-codec</code></dt><dt><code>utf-16le-codec</code></dt><dt><code>utf-16be-codec</code></dt><dt><code>utf-32le-codec</code></dt><dt><code>utf-32be-codec</code></dt><dd><p>These are predefined codecs for the ISO8859-1, UTF-16LE, UTF-16BE, UTF32-LE, and UTF-32BE encodings.</p></dd></dl><h2>Input and Output Streams</h2><p>The Stream I/O layer defines high-level I/O operations on two new datatypes: <i>input streams</i> and <i>output streams</i>.  These operations include binary and textual I/O.  Input streams are treated in lazy functional style: input from a stream <var>s</var> yields an object representing the input itself, and a new  input stream <var>s1</var>.  <var>S</var> will continue to represent exactly the same position within the input; to advance within the stream, the program needs to perform input from <var>s1</var>.  Consequently, input streams allow arbitrary lookahead, which is especially convenient for all kinds of scanning.</p><p>Output streams are more conventional, as the lazy functional style does not make sense with output.</p><p>Both input streams and output streams are either directly connected to underlying readers and writers, or are defined by translation on an underlying stream.  This makes it possible to perform trivial transformations such as CR/LF translation, but also transparent recoding on the streams.</p><p>Textual I/O always uses UTF-8 as the underlying encoding.  Other encodings can easily be supported by translating to or from UTF-8 using the translation framework.  If a decoding error occurs, the implicit decoder will skip the octet starting the character encoding, yield a ? character, and attempt to continue decoding after that initial octet.</p><p>The Stream I/O layer adds an additional condition type to the condition types specified in <a href="http://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>.</p><pre>(define-condition-type &amp;i/o-stream-error &amp;i/o-error
  i/o-stream-error?
  (stream i/o-error-stream))
</pre><p>The <code>stream</code> field has purely informational purpose.  Conditions raised in by Stream I/O procedures <em>may</em> include an <code>&amp;i/o-stream-error</code> condition, but are not required to do so.</p><h3>Input streams</h3><p>Input streams come in two flavors: either directly based on a reader, or based on another input stream via translation.  Input streams are in one of three states: active, truncated, or closed.  When initially created, a stream is active.  A program can retrieve the reader underlying an input stream---this automatically incurs disconnecting the stream from the reader, and puts the stream into the truncated state.  When explicitly closed, the reader underlying an open input stream is closed as well.  The closed state implies the truncated state.</p><p>Reading from a truncated stream is not an error; after all the existing buffers having been exhausted, the stream behaves as if an infinite sequence of end of files followed.</p><dl><dt><code>(input-stream? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is an input stream, <code>#f</code> otherwise.</p></dd><dt><a name="input-blob-some"><code>(input-blob-some </code><var>input-stream</var><code>)</code></a></dt><dd><p>This returns two values: a value and another input stream.  The input stream returned points exactly past the data read. If any data is available before the next end of file, this returns a freshly allocated blob of non-zero size containing that data.  If an end of file has been reached, the value is <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><a name="input-u8"><code>(input-u8 </code><var>input-stream</var><code>)</code></a></dt><dd><p>This returns two values: a value and another input stream.  The input stream returned points exactly past the data read. If an octet is available before the next end of file, this returns that octet as an exact integer.  If an end of file has been reached, the value is <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><a name="input-blob-n"><code>(input-blob-n </code><var>input-stream</var> <var>n</var><code>)</code></a></dt><dd><p><var>N</var> must be an exact, non-negative integer, specifying the number of octets to be read.  This returns two values: a value and another input stream.  It tries to read <var>n</var> octets.  If <var>n</var> or more octets are available before the next end of file, it returns a blob of size <var>n</var>.  If fewer octets are available before the next end of file, it returns a blob containing those octets. The input stream returned points exactly past the data read. If end of file has been reached, the return value is <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><a name="input-blob-n!"><code>(input-blob-n! </code><var>input-stream</var> <var>blob</var> <var>start</var> <var>count</var><code>)</code></a></dt><dd><p><var>Count</var> must be an exact, non-negative integer, specifying the number of octets to be read. <var>Blob</var> must be a blob with at least <code>(+ <var>start</var> <var>count</var>)</code> elements. This returns two values: a value and another input stream.  It tries to read <var>count</var> octets.  If <var>count</var> or more octets are available before the next end of file, they are written into <var>blob</var> starting at index <var>start</var>, and it returns <var>count</var> as the value. If fewer octets are available before the next end of file, it writes the available octets into <var>blob</var> starting at index <var>start</var>, and it returns the number of octets actually read as the value. The input stream returned points exactly past the data read. If end of file has been reached, the return value is <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><a name="input-blob-all"><code>(input-blob-all </code><var>input-stream</var><code>)</code></a></dt><dd><p>This returns two values: a value and another input stream.  If data is available before the next end of file, the value is a blob containing all octets until that end of file.  If not, the value is <code>#f</code>. The input stream returned points just past the end of file.  Note that this function may block indefinitely on streams connected to interactive readers, even though data is available.</p></dd><dt><a name="input-string"><code>(input-string </code><var>input-stream</var><code>)</code></a></dt><dd><p>This returns two values: a value and another input stream.  The input stream returned points exactly past the data read. If any data representing a string is available before the next end of file, this returns a string of non-zero size containing the UTF-8 decoding of that data as the first return value.  If an end of file has been reached, it returns <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><a name="input-char"><code>(input-char </code><var>input-stream</var><code>)</code></a></dt><dd><p>This returns two values: a value and another input stream.  The input stream returned points exactly past the data read. If a char is available before the next end of file, this returns that char.  If an end of file has been reached, the value is <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><a name="input-string-n"><code>(input-string-n </code><var>input-stream</var> <var>n</var><code>)</code></a></dt><dd><p><var>N</var> must be an exact, non-negative integer, specifying the number of chars to be read.  This returns two values: a value and another input stream.  The input stream returned points exactly past the data read. It tries to read <var>n</var> chars.  If <var>n</var> or more chars are available before the next end of file, it returns a string of size <var>n</var> consisting of those chars.  If fewer chars are available before the next end of file, it returns a string containing those chars.  If end of file has been reached, it returns <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><a name="input-string-n!"><code>(input-string-n! </code><var>input-stream</var> <var>string</var> <var>start</var> <var>count</var><code>)</code></a></dt><dd><p><var>Count</var> must be an exact, non-negative integer, specifying the number of chars to be read.  This returns two values: a value and another input stream.  The input stream returned points exactly past the data read. It tries to read <var>count</var> chars.  If <var>count</var> or more chars are available before the next end of file, they are written into <var>string</var> starting at index <var>start</var>, and it returns <var>count</var> as the value. If fewer chars are available before the next end of file, it writes the available chars into <var>string</var> starting at index <var>start</var>, and it returns the number of chars actually read as the value. If end of file has been reached, it returns <code>#f</code>, and the input stream returned points just past the end of file.  This procedure will block until either data is available or end of file is reached.</p></dd><dt><a name="input-string-all"><code>(input-string-all </code><var>input-stream</var><code>)</code></a></dt><dd><p>This returns two values: a value and another input stream.  If data is available before the next end of file, the value returned is a string contains all text until the next end of file.  If no data is available, the value is <code>#f</code>. The input stream returned points just past the end of file.  Note that this function may block indefinitely on streams connected to interactive readers, even though data is available.</p></dd><dt><a name="input-line"><code>(input-line </code><var>input-stream</var><code>)</code></a></dt><dd><p>This returns two values: a value and another input stream.  If data is available before the next newline char, the value is a string that contains all text until the newline char.  The input stream returned points just past the newline char.If end of file has been reached, the value is <code>#f</code>.</p></dd><dt><a name="stream-eof?"><code>(stream-eof? </code><var>input-stream</var><code>)</code></a></dt><dd><p>This returns <code>#t</code> if the stream has reached end of file, <code>#f</code> otherwise.</p></dd><dt><a name="input-stream-position"><code>(input-stream-position </code><var>input-stream</var><code>)</code></a></dt><dd><p>For reader-based input streams, this returns the reader position corresponding to the next octet read from the input stream.  This procedure raises an <code>&amp;i/o-operation-not-available-error</code> condition if the stream does not support the operation.  It is an error to apply this procedure to a truncated or closed stream, or to a translated stream.</p></dd><dt><code>(input-stream-underliers </code><var>input-stream</var><code>)</code></dt><dd><p><var>Input-stream</var> must be an open input stream.  This returns two values.  If the stream is translated, the first value is the underlying stream, and the second value is the translator procedure.  If the stream is based on a reader, this returns the reader as the first value and <code>#f</code> as the second.  Moreover, <var>input-stream</var> is put into the truncated state.</p><p>Note that, in the case of a translated stream, the returned underlying stream may already point past the data read by operations on <var>input-stream</var> due to buffering.</p></dd><dt><code>(input-stream-reader+constructor </code><var>input-stream</var><code>)</code></dt><dd><p><var>Input-stream</var> must be an open input stream.  This returns two values: a reader and a procedure of one argument.  The reader is the underlying reader of the stream at the end of the chain of translations whose head is <var>input-stream</var>.  The procedure consumes a reader as its argument and returns a fresh input stream with the same chain of translations as <var>input-stream</var>.  This also disconnects the input stream from the reader and puts it into the truncated state; all other input streams based on the input stream at the end of the translation chain  (directly or indirectly) are also put into the truncated state.</p></dd><dt><a name="close-input-stream"><code>(close-input-stream </code><var>input-stream</var><code>)</code></a></dt><dd><p>This closes the underlying reader if <var>input-stream</var> is still open, and marks the input stream as closed.  Applying <code>close-input-stream</code> to a closed stream has no effect.  Closing an input stream also closes all input streams that are translations  (directly or indirectly) of the input stream at the end of its own translation chain.  The return values are unspecified.</p></dd><dt><code>(open-file-input-stream </code><var>filename</var><code>)</code></dt><dt><code>(open-file-input-stream </code><var>filename</var> <var>file-options</var><code>)</code></dt><dd><p>This opens a reader connected to the file named by <var>filename</var>, passing it <var>file-options</var> if present, and returns an input stream connected to it.</p></dd><dt><code>(open-blob-input-stream </code><var>blob</var><code>)</code></dt><dd><p>This opens a blob reader connected to <var>blob</var> and returns an input stream connected to it.</p></dd><dt><code>(open-string-input-stream </code><var>string</var><code>)</code></dt><dd><p>This opens a blob reader connected to the UTF-8 encoding of <var>string</var> and returns an input stream connected to it.</p></dd><dt><code>(open-reader-input-stream </code><var>reader</var><code>)</code></dt><dt><code>(open-reader-input-stream </code><var>reader</var> <var>blob</var><code>)</code></dt><dd><p>This returns an input stream connected to the reader <var>reader</var>.</p><p>If <var>blob</var> is present, the stream will use it as its initial buffer contents.  Subsequently writing to <var>blob</var> directly has unspecified consequences.</p></dd><dt><code>(call-with-input-stream </code><var>input-stream</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> with <var>input-stream</var> as an argument.  If <var>proc</var> returns, then the stream is closed automatically and the values returned by <var>proc</var> are returned.  If <var>proc</var> does not return, then the stream will not be closed automatically, unless it is possible to prove that the stream will never again be used for a read operation.</p></dd><dt><a name="make-translated-input-stream"><code>(make-translated-input-stream </code><var>input-stream</var> <var>translate-proc</var><code>)</code></a></dt><dt><code>(make-translated-input-stream </code><var>input-stream</var> <var>translate-proc</var> <var>blob</var><code>)</code></dt><dd><p>This returns a translated input stream based on <var>input-stream</var>.  <var>Translate-proc</var> must be a procedure that adheres to the following specification:</p><dl><dt><code>(</code><var>translate-proc</var> <var>input-stream</var> <var>wish</var><code>)</code></dt><dd><p><var>Input-stream</var> is the underlying input stream originally passed to <code>make-translated-input-stream</code>.  <var>Wish</var> is either <code>#f</code>, <code>#t</code>, or an exact, non-negative integer, giving a hint how much data is requested.  <code>#f</code> means a chunk of arbitrary size, suggesting that the user program called <code>input-blob-some</code>, <code>#t</code> means as much as possible, suggesting that the user program  called <code>user-input-all</code>, and an integer specifies the requested  number of octets.  Note that <var>translate-proc</var> can ignore <var>wish</var>.  The procedure must return two values, a blob, and another input stream, analogous to the various <code>input-...</code> procedures.  <code>#f</code> denotes an end of file.  The returned input stream points just past the data returned.</p></dd></dl><p>If <var>blob</var> is present, the stream will use it as its initial (translated) buffer contents.  Subsequently writing to <var>blob</var> directly has unspecified consequences.</p></dd><dt><a name="transcode-input-stream"><code>(transcode-input-stream </code><var>input-stream</var> <var>transcoder</var><code>)</code></a></dt><dd><p>This creates a transcoded input stream from <var>input-stream</var>, assuming <var>input-stream</var> has the encoding specified by <var>transcoder</var>.  It will translate the data from <var>input-stream</var> into UTF-8 with end-of-line encoded by U+000A.</p></dd><dt><code>(standard-input-stream)</code></dt><dd><p>Return a freshly created stream connected to the standard input reader. Note that a program should not keep the returned stream live, as standard input read in other parts of the program accumulate buffer space.</p></dd></dl><h3>Output streams</h3><p>Output streams, like input streams, come in two flavors: either directly based on a writer, or based on another output stream via translation.  </p><p>Output streams are in one of three states: active, terminated, or closed.  When initially created, a stream is active.    A program can retrieve the writer underlying an output stream---this automatically incurs disconnecting the stream from the writer, and puts the stream into the terminated state.  When explicitly closed, the writer underlying an output stream enters the closed state.  The closed state implies the terminated state.</p><p>It is an error to perform an output operation on a terminated stream.</p><dl><dt><code>(output-stream? </code><var>obj</var><code>)</code></dt><dd><p>This returns <code>#t</code> if the argument is an output stream, <code>#f</code> otherwise.</p></dd><dt><a name="output-blob"><code>(output-blob </code><var>output-stream</var> <var>blob</var> <var>start</var> <var>count</var><code>)</code></a></dt><dt><code>(output-blob </code><var>output-stream</var> <var>blob</var> <var>start</var><code>)</code></dt><dt><code>(output-blob </code><var>output-stream</var> <var>blob</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers that default to 0 and <code>(- (blob-length <var>blob</var>) <var>start</var>)</code>, respectively.  This writes the <var>count</var> octets in blob <var>blob</var> starting at index <var>start</var> to the output stream.  It is an error if the blob actually has size less than <var>start</var> + <var>count</var>.  The return values are unspecified.</p></dd><dt><a name="output-u8"><code>(output-u8 </code><var>output-stream</var> <var>octet</var><code>)</code></a></dt><dd><p>This writes the octet <var>octet</var> (which must be an exact integer in the range [0,255]) to the stream.  The return values are unspecified.</p></dd><dt><a name="output-char"><code>(output-char </code><var>output-stream</var> <var>char</var><code>)</code></a></dt><dd><p>This writes the UTF-8 encoding of the char <var>char</var> to the stream.  The return values are unspecified.</p></dd><dt><a name="output-string"><code>(output-string </code><var>output-stream</var> <var>string</var> <var>start</var> <var>count</var><code>)</code></a></dt><dt><code>(output-string </code><var>output-stream</var> <var>string</var> <var>start</var><code>)</code></dt><dt><code>(output-string </code><var>output-stream</var> <var>string</var><code>)</code></dt><dd><p><var>Start</var> and <var>count</var> must be non-negative exact integers that default to 0 and <code>(- (string-length <var>blob</var>) <var>start</var>)</code>, respectively.  This writes the UTF-8 encoding of the substring <code>(substring <var>string</var> (+ <var>start</var> <var>count</var>))</code> to the stream.  The return values are unspecified.</p></dd><dt><a name="flush-output-stream"><code>(flush-output-stream </code><var>output-stream</var><code>)</code></a></dt><dd><p>This flushes any output from the buffer of <var>output-stream</var> to the underlying writer.  It is a no-op if <var>output-stream</var> is terminated.  The return values are unspecified.</p></dd><dt><a name="output-stream-position"><code>(output-stream-position </code><var>output-stream</var><code>)</code></a></dt><dd><p>For writer-based output streams, this returns the writer position corresponding to the next octet written to the output stream.  This procedure raises an <code>&amp;i/o-operation-not-available-error</code> condition if the stream does not support the operation.  It is an error to apply this procedure to a terminated or closed stream, or to a translated stream.</p></dd><dt><a name="set-output-stream-position!"><code>(set-output-stream-position! </code><var>output-stream</var> <var>pos</var><code>)</code></a></dt><dd><p><var>Pos</var> must be a non-negative exact integer.  This flushes the output stream and sets the current position of underlying writer to <var>pos</var>.  This procedure raises an <code>&amp;i/o-operation-not-available-error</code> condition if the stream does not support the operation.  It is an error to apply this procedure to a terminated or closed stream, or to a translated stream.  The return values are unspecified.</p></dd><dt><code>(output-stream-underliers </code><var>output-stream</var><code>)</code></dt><dd><p><var>Output-stream</var> must be an open output stream.  First, this flushes <var>output-stream</var>.  This returns three values:  If <var>output-stream</var> is a translated stream, the first value is the underlying stream, the second value the translation procedure, and the third value the translation state of the stream.  If it is directly based on a writer, the first return value is the writer; the second and the third are <code>#f</code>.</p></dd><dt><code>(output-stream-writer+constructor </code><var>output-stream</var><code>)</code></dt><dd><p><var>Output-stream</var> must be an open output stream.  First, this flushes <var>output-stream</var>.  This returns two values: a writer and a procedure of one argument.  The writer is the underlying writer of the stream at the end of the chain of translations whose head is <var>output-stream</var>.  The procedure consumes a writer as its argument and returns a fresh output stream with the same chain of translations as <var>output-stream</var>, where each translation is in the same state as in the chain.  This also disconnects the output stream from the writer and puts it into the terminated state; all other output streams based on the output stream at the end of the translation chain  (directly or indirectly) are also put into the truncated state.</p></dd><dt><a name="close-output-stream"><code>(close-output-stream </code><var>output-stream</var><code>)</code></a></dt><dd><p>This closes the underlying writer if <var>output-stream</var> is still open, and marks the output stream as closed.  Applying <code>close-output-stream</code> to a closed stream has no effect.  Closing an output stream also closes all output streams that are translations  (directly or indirectly) of the output stream at the end of its own translation chain.  The return values are unspecified.</p></dd><dt><a name="output-stream-buffer-mode"><code>(output-stream-buffer-mode </code><var>output-stream</var><code>)</code></a></dt><dd><p>This returns the buffer-mode object of <var>output-stream</var>.</p></dd><dt><a name="set-output-stream-buffer-mode!"><code>(set-output-stream-buffer-mode! </code><var>output-stream</var> <var>buffer-mode</var><code>)</code></a></dt><dd><p>If the current buffer mode of <var>output-stream</var> is something other than <code>none</code> and <var>buffer-mode</var> is the <code>none</code> buffer-mode object, this will first flush the output stream.  Then, it sets the buffer-mode object associated with <var>output-stream</var> to <var>buffer-mode</var>.  The return values are unspecified.</p></dd><dt><code>(open-file-output-stream </code><var>filename</var><code>)</code></dt><dt><code>(open-file-output-stream </code><var>filename</var> <var>file-options</var><code>)</code></dt><dd><p>This opens a writer connected to the file named by <var>filename</var> via <code>open-file-writer</code> (passing it <var>file-options</var>, which defaults to <code>(file-options)</code>) and returns an output stream with unspecified buffering mode connected to it. </p></dd><dt><code>(open-writer-output-stream </code><var>writer</var> <var>buffer-mode</var><code>)</code></dt><dd><p>This returns an output stream connected to the writer <var>writer</var> with buffering according to <var>buffer-mode</var>.</p></dd><dt><code>(call-with-blob-output-stream </code><var>proc</var><code>)</code></dt><dd><p><var>Proc</var> is a procedure accepting one argument.  This creates an unbuffered output stream connected to a blob writer, and calls <var>proc</var> with that output stream as an argument.  The call to <code>call-with-blob-output-stream</code> returns the blob associated with the stream when <var>proc</var> returns.</p></dd><dt><code>(call-with-string-output-stream </code><var>proc</var><code>)</code></dt><dd><p><var>Proc</var> is a procedure accepting one argument.  This creates an unbuffered output stream connected to a blob writer, and calls <var>proc</var> with that output stream as an argument.  The call to <code>call-with-string-output-stream</code> returns the UTF-8 decoding of the blob associated with the stream when <var>proc</var> returns.</p></dd><dt><code>(call-with-output-stream </code><var>output-stream</var> <var>proc</var><code>)</code></dt><dd><p>This calls <var>proc</var> with <var>output-stream</var> as an argument.  If <var>proc</var> returns, then the stream is closed automatically and the values returned by <var>proc</var> are returned.  If <var>proc</var> does not return, then the stream will not be closed automatically, unless it is possible to provide that the stream will never again be used for a write operation.</p></dd><dt><a name="make-translated-output-stream"><code>(make-translated-output-stream </code><var>output-stream</var> <var>translate-proc</var> <var>state</var><code>)</code></a></dt><dd><p>This returns a translated output stream based on <var>output-stream</var>.  The translation can thread an arbitrary state from one output operation to the next; the initial state is given by <var>state</var>.  <var>Translate-proc</var> must be a procedure that adheres to the following specification:</p><dl><dt><code>(</code><var>translate-proc</var> <var>output-stream</var> <var>state</var> <var>data</var> <var>start</var> <var>count</var><code>)</code></dt><dd><p>This is expected to write the output data in <var>data</var> to <var>output-stream</var>, which is the output stream passed into <code>make-translated-output-stream</code>.  <var>State</var> is the translation state associated with the output stream. <var>Data</var> is the data to be written: it is either <code>#f</code>, a blob or an octet represented an an exact integer.  If <var>data</var> is a blob, <var>start</var> is an exact integer representing the starting index of the data to be written within <var>data</var>.  <var>Count</var> is the number of data octets within <var>data</var> to be written.  (Otherwise, the values of <var>start</var> and <var>count</var> are unspecified.</p><p>If <var>data</var> is <code>#f</code>, this means that the stream is being flushed, and the translation procedure should write out any remaining data encoded in <var>state</var> to the output-stream, and possibly synchronize the protocol.</p><p>The procedure must return a new state object, which will be passed to the next call to <var>translate-proc</var>.  It is recommended that <var>translate-proc</var> not modify <var>state</var> itself, but rather generate a new state object if necessary.  Otherwise, the constructor procedure returned by <code>output-stream-writer+constructor</code> may not operate correctly.</p></dd></dl></dd><dt><a name="transcode-output-stream"><code>(transcode-output-stream </code><var>output-stream</var> <var>transcoder</var><code>)</code></a></dt><dd><p>This creates a transcoded output stream from <var>output-stream</var>, translating the data fed into <var>output-stream</var> into the encoding specified by <var>transcoder</var>, assuming it is encoded as UTF-8 with end-of-line encoded by U+000A.</p></dd><dt><code>(standard-output-stream)</code></dt><dt><code>(standard-error-stream)</code></dt><dd><p>This returns output streams on the standard output writer and standard error writer, respectively.</p></dd></dl><h3>Opening files for reading and writing</h3><dl><dt><code>(open-file-input+output-streams </code><var>filename</var><code>)</code></dt><dt><code>(open-file-input+output-streams </code><var>filename</var> <var>file-options</var><code>)</code></dt><dd><p>This opens a reader and a writer connected to the file named by <var>filename</var> via <code>open-file-reader+writer</code> (passing it <var>file-options</var>, which defaults to <code>(file-options)</code>) and returns an input stream and an output stream with unspecified buffering mode connected to them.</p></dd></dl><h1>Design rationale</h1><h3>Encoding</h3><p>Many I/O system implementations allow associating an encoding with a port, allowing the direct use of several different encodings with ports.  The problem with this approach is that the encoding/decoding defines a mapping from binary data to text or vice versa.  Because of this asymmetry, such mappings do not compose.  The result is usually complications and restrictions in the I/O API, such as the inability to mix text or binary data.</p><p>This SRFI avoids this problem by specifying that textual I/O always uses UTF-8.  This means that, if the target or source of an I/O stream is to use a different encoding, a translated stream needs to be used, for which this SRFI offers the required facilities.  This means that text decoders or encoders are expressed as binary-to-binary mappings, and as such compose.</p><h3>No distinct end of file object</h3><p>In R5RS, the distinct type of end of file objects is primarily for the benefit of <code>read</code>, where end of file must be denoted by an object that <code>read</code> cannot normally return as a result of parsing the input.  However, it does not seem necessary to drag in the complications of this separate object into the other I/O operations, where <code>#f</code> is perfectly adequate to represent end of file.</p><h1>Reference Implementation</h1><p><a href="http://srfi.schemers.org/srfi-79/implementation/comprehensive-io-reference.tar.gz">Here</a> is a tarball containing a reference implementation of this SRFI, along with implementations for <a href="http://srfi.schemers.org/srfi-79/">SRFI 79 (Primitive I/O)</a>, <a href="http://srfi.schemers.org/srfi-81/">SRFI 81 (Port I/O)</a>, and <a href="http://srfi.schemers.org/srfi-82/">SRFI 82 (Stream-Port I/O)</a>.  It only runs on a version of Scheme 48 that has not been released at the time of writing in this SRFI.</p><p>However, its actual dependencies on Scheme 48 idiosyncracies are few.  Chief are its use of the module system, which is easily replaced by another, and the implementation of Unicode.  To implement primitive readers and writers on files, the code only relies on suitable library procedures to open the files, and <code>read-byte</code> and <code>write-byte</code> procedures to read or write single bytes from a (R5RS) port, as well as a <code>force-output</code> procedure to flush a port.</p><p>The reference implementation has not been highly tuned, but I have spent a modest amount of time making the code deal with buffers in an economic buffer.  Because of this, the code is more complicated than it needs to be, but hopefully also more usable as a basis for implementing this SRFI in actual Scheme systems.</p><h1>Examples</h1><p>Many examples are adapted from <a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a> edited by Emden R. Gansner and John H. Reppy.  Cambrige University Press, 2004.</p><p>The code makes liberal use of SRFIs <a href="http://srfi.schemers.org/srfi-1/"> SRFI 1 (List Library)</a>, <a href="http://srfi.schemers.org/srfi-11/">SRFI 11 (Syntax for receiving multiple values)</a>, <a href="http://srfi.schemers.org/srfi-26/">SRFI 26 (Notation for Specializing Parameters without Currying)</a>.</p><p>The tarball with the reference implementation contains these examples along with test cases for them.</p><p>For input streams, the successive streams need to be threaded through the program:</p><pre>(define (input-two-lines s)
  (let*-values (((line-1 s-2) (input-line s))
                ((line-2 _)   (input-line s-2)))
    (values line-1 line-2)))
</pre><p>There may be life after end of file; hence, the following is not guaranteed to return true:</p><pre>(define (at-end?/broken s)
  (let ((z (stream-eof? s)))
    (let-values (((a s-2) (input-blob-some s)))
      (let ((x (stream-eof? s-2)))
        (equal? z x)))))
</pre><p>... but this is:</p><pre>(define (at-end? s)
  (let ((z (stream-eof? s)))
    (let-values (((a s-2) (input-blob-some s)))
      (let ((x (stream-eof? s)))
        (equal? z x)))))
</pre><p>Catch an I/O exception:</p><pre>(define (open-it filename)
  (guard
   (condition
    ((i/o-error? condition)
     (if (message-condition? condition)
         (begin
           (write-string (standard-error-port)
                         (condition-message condition))
           (newline (standard-error-port))))
     #f))
   (open-file-input-stream filename)))
</pre><p>Read a file using Stream I/O:</p><pre>(define (get-contents/stream filename)
  (call-with-input-stream (open-file-input-stream filename)
    (lambda (stream)
      (let-values (((blob _) (input-blob-all stream)))
        blob))))
</pre><p>Read a file octet by octet:</p><pre>(define (get-contents/stream-2 filename)
  (call-with-input-stream (open-file-input-stream filename)
    (lambda (stream)
      (let loop ((accum '()) (stream stream))
        (let-values (((octet stream) (input-u8 stream)))
          (if (not octet)
              (list-&gt;blob (reverse accum))
              (loop (cons octet accum) stream)))))))
</pre><p>Read a file chunk-by-chunk:</p><pre>(define (get-contents/stream-3 filename)
  (call-with-input-stream (open-file-input-stream filename)
    (lambda (stream)
      (let loop ((accum '()) (stream stream))
        (let-values (((chunk stream) (input-blob-some stream)))
          (if chunk
              (loop (cons chunk accum) stream)
              (concatenate-blobs (reverse accum))))))))

(define (concatenate-blobs list)
  (let* ((size (fold + 0 (map blob-length list)))
         (result (make-blob size)))
    (let loop ((index 0)
               (blobs list))
      (if (null? blobs)
          result
          (let* ((b (car blobs))
                 (size (blob-length b)))
            (blob-copy! b 0 result index size)
            (loop (+ index size)
                  (cdr blobs)))))))
</pre><p>Drop a word at the beginning of a stream selectively:</p><pre>(define (eat-thousand stream)
  (let-values (((text new-stream)
                (input-string-n stream (string-length "thousand"))))
    (if (string=? text "thousand")
        new-stream
        stream)))
</pre><p>Skip whitespace at the beginning of a stream:</p><pre>(define (skip-whitespace stream)
  (let-values (((thing new-stream)
                (input-char stream)))
    (cond
     ((not thing) stream)
     ((char-whitespace? thing)
      (skip-whitespace new-stream))
     (else stream))))
</pre><p>Reading a line could be implemented by scanning forward, then reading a chunk from the original position:</p><pre>(define (my-input-line stream)
  (let count ((n 0) (g stream))
    (let-values (((thing g*) (input-char g)))
      (cond
       ((not thing)
        (if (zero? n)
            (values #f g*)
            (input-string-n stream n)))
       ((char=? #\newline thing)
        (let*-values (((line _) (input-string-n stream n)))
          (values line g*)))
       (else
        (count (+ 1 n) g*))))))
</pre><p>Write some text to a file:</p><pre>(define (hello myfile)
  (call-with-output-stream (open-file-output-stream myfile (file-options truncate create))
    (lambda (stream)
      (output-string stream "Hello, ")
      (output-string stream "world!")
      (output-char stream #\newline))))
</pre><p>Extract the reader from a stream, read a octet from it, and then reconstruct a stream from it:</p><pre>(define (after-first filename)
  (let ((stream (open-file-input-stream filename)))
    (call-with-values
        (lambda () (input-stream-reader+constructor stream))
      (lambda (reader construct)
        (let ((b (make-blob 1)))
          (reader-read! reader b 0 1)
          (call-with-input-stream (construct reader)
            (lambda (stream-2)
              (let-values (((contents _) (input-string-all stream-2)))
                contents))))))))
</pre><p>Extract the reader from a stream, set position, and then reconstruct a stream from it:</p><pre>(define (after-n stream n)
  (call-with-values
      (lambda () (input-stream-reader+constructor stream))
    (lambda (reader construct)
      (reader-set-position! reader n)
       (call-with-input-stream (construct reader)
         (lambda (stream-2)
           (let-values (((contents _) (input-string-all stream-2)))
             contents))))))
</pre><p>Translate CR/LF to LF on input:</p><pre>(define (translate-crlf-input original-input-stream wish)

  ;; state automaton

  (define (vanilla input-stream count)
    (call-with-values
        (lambda ()
          (input-u8 input-stream))
      (lambda (octet input-stream)
        (cond
         ((not octet) (finish count))
         ((= 13 octet) (cr input-stream count))
         (else (vanilla input-stream (+ 1 count)))))))
            
  (define (cr input-stream count)
    (call-with-values
        (lambda ()
          (input-u8 input-stream))
      (lambda (octet input-stream)
        (cond
         ((not octet) (finish (+ 1 count)))     ; CR hasn't been counted yet
         ((= 10 octet)
          (call-with-values
              (lambda ()
                (input-blob-n original-input-stream (+ 1 count)))
            (lambda (blob _)
              (blob-u8-set! blob count 10)
              (values blob input-stream))))
         (else (vanilla input-stream (+ count 1)))))))

  (define (finish count)
    (if (zero? count)
        (let-values (((_ past-eof) (input-u8 original-input-stream)))
          (values #f past-eof))
        (call-with-values
            (lambda ()
              (input-blob-n original-input-stream count))
          (lambda (blob input-stream)
            (values blob input-stream)))))
          
  (vanilla original-input-stream 0))

(define (make-crlf-translated-input-stream input-stream)
  (make-translated-input-stream input-stream
                                translate-crlf-input))
</pre><p>Translate LF to CR/LF on output:</p><pre>(define (translate-crlf-output output-stream state data start count)
  (cond
   ((not data))
   ((blob? data)
    (let ((end (+ start count)))
      (let loop ((index start))
        (cond
         ((blob-index data 10 index end)
          =&gt; (lambda (lf-index)
               (output-blob output-stream data index (- lf-index index))
               (output-u8 output-stream 13)
               (output-u8 output-stream 10)
               (loop (+ 1 lf-index))))
         (else
          (output-blob output-stream data index (- end index)))))))
   ((= data 10)
    (output-u8 output-stream 13)
    (output-u8 output-stream 10))
   (else
    (output-u8 output-u8 data)))
  (unspecific))

(define (blob-index blob octet start end)
  (let loop ((index start))
    (cond
     ((&gt;= index end)
      #f)
     ((= octet (blob-u8-ref blob index))
      index)
     (else
      (loop (+ 1 index))))))
</pre><p>Transcoder round trip:</p><pre>(define (transcoder-round-trip transcoder text)
  (let* ((coded
          (call-with-blob-output-stream
           (lambda (output-stream)
             (let ((output-stream
                    (transcode-output-stream output-stream transcoder)))
               (output-string output-stream text)))))

         (input-stream (open-blob-input-stream coded))
         (input-stream (transcode-input-stream input-stream transcoder)))
    (let-values (((text _) (input-string-all input-stream)))
      text)))
</pre><p>Decoding UTF-32LE via transcoders:</p><pre>(define (decode-utf-32le blob)
  (let* ((input-stream (open-blob-input-stream blob))
         (input-stream (transcode-input-stream input-stream
                                               (transcoder (codec utf-32le-codec)))))
    (let-values (((text _) (input-string-all input-stream)))
      text)))
</pre><h1>Acknowledgements</h1><p>Sebastian Egner provided valuable comments on a draft of this SRFI. The posters to the <a href="http://srfi.schemers.org/srfi-68/">SRFI 68 (Comprehensive I/O)</a> provided many very valuable comments.  Donovan Kolbly did thorough pre-draft editing.  Any remaining mistakes are mine.</p><h1>References</h1><ul><li><a href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a> edited by Emden R. Gansner and John H. Reppy.  Cambrige University Press, 2004.</li></ul><H1>Copyright</H1>
Copyright (C) Michael Sperber (2005). All Rights Reserved. 
<p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

    <hr>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">Donovan Kolbly</a></address>
</body></html>
