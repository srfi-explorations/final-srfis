;; Copyright (C) Marc Nieper-WiÃŸkirchen (2017).  All Rights Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(define-syntax %set!
  (syntax-rules ()
    ((%set! variable expression)
     (begin
       (set! variable expression)
       unspecified))))

(define (%set-box! box value)
  (set-box! box value)
  unspecified)

(define-syntax define-primitive
  (syntax-rules ()
    ((define-primitive name proc)
     (define (name flag marks . args)
       (apply proc args)))))

(define-syntax define-primitive/void
  (syntax-rules ()
    ((define-primitive/void name proc)
     (define (name flag marks . args)
       (apply proc args)
       unspecified))))

(define (%apply flag marks proc . args)
  (apply apply proc flag marks args))

(define (%for-each flag marks proc . lists)
  (apply for-each (lambda args
		    (apply proc #f marks args))
	 lists)
  unspecified)

(define (%map flag marks proc . lists)
  (apply map (lambda args
	       (apply proc #f marks args))
	 lists))

(define (%call-with-current-continuation flag marks proc)
  (call-with-current-continuation
   (lambda (c)
     (proc flag marks (lambda (flag marks . args)
			(apply c args))))))

(define (%call-with-input-file flag marks string proc)
  (call-with-input-file string (lambda (port)
				 (proc #f marks port))))

(define (%call-with-output-file flag marks string proc)
  (call-with-output-file string (lambda (port)
				  (proc #f marks port))))

(define continuation-marks (vector 'continuation-marks))

(define (%with-continuation-mark flag marks key value)
  (let ((pair (cons key value)))
    (if flag
	(cons (let loop ((first-marks (car marks)))
		(cond
		 ((null? first-marks)
		  (list pair))
		 ((eq? key (caar first-marks))
		  (cons pair (cdr first-marks)))
		 (else
		  (cons (car first-marks)
			(loop (cdr first-marks))))))
	      (cdr marks))
	(cons (list pair) marks))))

(define (%current-continuation-marks flag marks)
  (cons continuation-marks marks))

(define (%continuation-marks? flag marks obj)
  (and (pair? obj)
       (eq? continuation-marks (car obj))))

(define (%continuation-mark-set->list flag marks mark-set key)
  (let loop ((mark-set (cdr mark-set)))
    (cond
     ((null? mark-set)
      '())
     ((assq key (car mark-set))
      => (lambda (pair)
	   (cons (cdr pair) (loop (cdr mark-set)))))
     (else
      (loop (cdr mark-set))))))

(define (any pred list)
  (let loop ((list list))
    (and (not (null? list))
	 (or (pred (car list))
	     (loop (cdr list))))))

(define (%continuation-mark-set->list* flag marks mark-set list . default*)
  (let ((default (and (not (null? default*)) (car default*))))
    (let loop ((mark-set (cdr mark-set)))
      (cond
       ((null? mark-set)
	'())
       ((not (any (lambda (key)
		    (assq key (car mark-set)))
		  list))
	(loop (cdr mark-set)))
       (else
	(cons (list->vector (map (lambda (key)
				   (cond
				    ((assq key (car mark-set)) => cdr)
				    (else default)))
				 list))
	      (loop (cdr mark-set))))))))

(define (%continuation-mark-set-first flag marks mark-set key . default*)
  (let ((default (and (not (null? default*)) (car default*))))
    (let loop ((mark-set (cdr mark-set)))
      (cond
       ((null? mark-set) default)
       ((assq key (car mark-set)) => cdr)
       (else (loop (cdr mark-set)))))))

(define (%call-with-immediate-continuation-mark flag marks key proc . default*)
  (let ((default (and (not (null? default*)) (car default*))))
    (let ((mark (and flag
		     (cond
		      ((assq key (car marks)) => cdr)
		      (else default)))))
      (proc flag marks mark))))

(define (%load flag marks filename)
  (call-with-input-file filename
    (lambda (port)
      (let loop ()
	(let ((expression (read port)))
	  (unless (eof-object? expression)
	    (let-values ((result (eval expression (interaction-environment))))
	      (for-each
	       (lambda (value)
		 (unless (unspecified? value)
		   (write value)
		   (newline)))
	       result))
	    (loop))))))
  unspecified)

(define-primitive %= =)
(define-primitive %< <)
(define-primitive %> >)
(define-primitive %<= <=)
(define-primitive %>= >=)
(define-primitive %+ +)
(define-primitive %* *)
(define-primitive %- -)
(define-primitive %/ /)
(define-primitive %abs abs)
(define-primitive %append append)
(define-primitive %angle angle)
(define-primitive %assoc assoc)
(define-primitive %assq assq)
(define-primitive %assv assv)
(define-primitive %acos acos)
(define-primitive %asin asin)
(define-primitive %atan atan)
(define-primitive %boolean? boolean?)
(define-primitive %car car)
(define-primitive %cdr cdr)
(define-primitive %caar caar)
(define-primitive %cadr cadr)
(define-primitive %cdar cdar)
(define-primitive %cddr cddr)
(define-primitive %caaar caaar)
(define-primitive %caadr caadr)
(define-primitive %cadar cadar)
(define-primitive %caddr caddr)
(define-primitive %cdaar cdaar)
(define-primitive %cdadr cdadr)
(define-primitive %cddar cddar)
(define-primitive %cdddr cdddr)
(define-primitive %caaaar caaaar)
(define-primitive %caaadr caaadr)
(define-primitive %caadar caadar)
(define-primitive %caaddr caaddr)
(define-primitive %cadaar cadaar)
(define-primitive %cadadr cadadr)
(define-primitive %caddar caddar)
(define-primitive %cadddr cadddr)
(define-primitive %cdaaar cdaaar)
(define-primitive %cdaadr cdaadr)
(define-primitive %cdadar cdadar)
(define-primitive %cdaddr cdaddr)
(define-primitive %cddaar cddaar)
(define-primitive %cddadr cddadr)
(define-primitive %cdddar cdddar)
(define-primitive %cddddr cddddr)
(define-primitive %ceiling ceiling)
(define-primitive %char? char?)
(define-primitive %char=? char=?)
(define-primitive %char<? char<?)
(define-primitive %char>? char>?)
(define-primitive %char<=? char<=?)
(define-primitive %char>=? char>=?)
(define-primitive %char-alphabetic? char-alphabetic?)
(define-primitive %char-downcase char-downcase)
(define-primitive %char-ci=? char-ci=?)
(define-primitive %char-ci<? char-ci<?)
(define-primitive %char-ci>? char-ci>?)
(define-primitive %char-ci<=? char-ci<=?)
(define-primitive %char-ci>=? char-ci>=?)
(define-primitive %char->integer char->integer)
(define-primitive %char-lower-case? char-lower-case?)
(define-primitive %char-numeric? char-numeric?)
(define-primitive %char-upcase char-upcase)
(define-primitive %char-upper-case? char-upper-case?)
(define-primitive %char-whitespace? char-whitespace?)
(define-primitive/void %close-input-port close-input-port)
(define-primitive/void %close-output-port close-output-port)
(define-primitive %complex? complex?)
(define-primitive %cons cons)
(define-primitive %cos cos)
(define-primitive %current-input-port current-input-port)
(define-primitive %current-output-port current-output-port)
(define-primitive %denominator denominator)
(define-primitive/void %display display)
(define-primitive %eof-object? eof-object?)
(define-primitive %eq? eq?)
(define-primitive %equal? equal?)
(define-primitive %eqv? eqv?)
(define-primitive %even? even?)
(define-primitive %exact? exact?)
(define-primitive %exact->inexact exact->inexact)
(define-primitive %exp exp)
(define-primitive %expt expt)
(define-primitive %floor floor)
(define-primitive %gcd gcd)
(define-primitive %imag-part imag-part)
(define-primitive %inexact? inexact?)
(define-primitive %inexact->exact inexact->exact)
(define-primitive %input-port? input-port?)
(define-primitive %integer? integer?)
(define-primitive %integer->char integer->char)
(define-primitive %length length)
(define-primitive %lcm lcm)
(define-primitive %list list)
(define-primitive %list? list?)
(define-primitive %list-ref list-ref)
(define-primitive %log log)
(define-primitive %magnitude magnitude)
(define-primitive %make-rectangular make-rectangular)
(define-primitive %make-polar make-polar)
(define-primitive %make-string make-string)
(define-primitive %make-vector make-vector)
(define-primitive %max max)
(define-primitive %min min)
(define-primitive %member member)
(define-primitive %memq memq)
(define-primitive %memv memv)
(define-primitive %modulo modulo)
(define-primitive %negative? negative?)
(define-primitive/void %newline newline)
(define-primitive %not not)
(define-primitive %number? number?)
(define-primitive %number->string number->string)
(define-primitive %numerator numerator)
(define-primitive %null? null?)
(define-primitive %odd? odd?)
(define-primitive %open-input-file open-input-file)
(define-primitive %open-output-file open-output-file)
(define-primitive %output-port? output-port?)
(define-primitive %pair? pair?)
(define-primitive %positive? positive?)
(define-primitive %procedure? procedure?)
(define-primitive %quotient quotient)
(define-primitive %rational? rational?)
(define-primitive %rationalize rationalize)
(define-primitive %real? real?)
(define-primitive %real-part real-part)
(define-primitive %read read)
(define-primitive %read-char read-char)
(define-primitive %remainder remainder)
(define-primitive %reverse reverse)
(define-primitive %round round)
(define-primitive %peek-char peek-char)
(define-primitive/void %set-car! set-car!)
(define-primitive/void %set-cdr! set-cdr!)
(define-primitive %sin sin)
(define-primitive %sqrt sqrt)
(define-primitive %string string)
(define-primitive %string? string?)
(define-primitive %string=? string=?)
(define-primitive %string<? string<?)
(define-primitive %string>? string>?)
(define-primitive %string<=? string<=?)
(define-primitive %string>=? string>=?)
(define-primitive %string-append string-append)
(define-primitive %string-ci=? string-ci=?)
(define-primitive %string-ci<? string-ci<?)
(define-primitive %string-ci>? string-ci>?)
(define-primitive %string-ci<=? string-ci<=?)
(define-primitive %string-ci>=? string-ci>=?)
(define-primitive %string-length string-length)
(define-primitive %string-ref string-ref)
(define-primitive/void %string-set! string-set!)
(define-primitive %string->number string->number)
(define-primitive %string->symbol string->symbol)
(define-primitive %substring substring)
(define-primitive %symbol? symbol?)
(define-primitive %symbol->string symbol->string)
(define-primitive %tan tan)
(define-primitive %truncate truncate)
(define-primitive/void %write write)
(define-primitive %vector vector)
(define-primitive %vector? vector?)
(define-primitive %vector-length vector-length)
(define-primitive %vector-ref vector-ref)
(define-primitive/void %vector-set! vector-set!)
(define-primitive %zero? zero?)
