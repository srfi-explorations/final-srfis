<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
  <HEAD>
    <title>SRFI 58: Array Notation</title>
  </HEAD>

  <BODY>

<H1>Title</H1>

Array Notation

<H1>Authors</H1>

Aubrey Jaffer and Radey Shouman

<H1>Status</H1>

This SRFI is currently in ``draft'' status. To see an explanation of each
status that a SRFI can hold, see <A
href="http://srfi.schemers.org/srfi-process.html">here</A>. It will remain
in draft status until 2005/01/26, or as amended. To provide input on this
SRFI, please <CODE><A
HREF="mailto:srfi-58@srfi.schemers.org">mailto:srfi-58@srfi.schemers.org</A></CODE>.
See <A
href="../../srfi-list-subscribe.html">instructions
here</A> to subscribe to the list. You can access previous messages via <A
href="http://srfi.schemers.org/srfi-58/mail-archive/maillist.html">the
archive of the mailing list</A>.
<P>
<UL>
  <LI>Received: 2004/11/26</LI>
  <LI>Draft: 2004/11/26 - 2005/01/26</LI>
</UL>

<H1>Abstract</H1>

<A HREF="http://srfi.schemers.org/srfi-47/srfi-47.html">SRFI-47</A>
provides both uniform-typed and heterogeneous multidimensional arrays
which subsume Scheme vectors.  The notation presented here builds upon
Common-Lisp array sytnax to represent heterogeneous and uniform-typed
arrays.
<P>

<H1>Issues</H1>

<TABLE ALIGN=CENTER BORDER=1>
<CAPTION>Original Proposal</CAPTION>
<TR><TH>prototype<BR>procedure
    <TH>exactness
    <TH>element type
    <TD ALIGN=CENTER><B>prefix</B><BR>(rank = <I>n</I>)
<TR><TD><CODE>vector</CODE><TD>       <TD>any                               <TD><CODE>#<i>n</i>A   </CODE>
<TR><TD><CODE>ac64  </CODE><TD>inexact<TD>IEEE 64.bit floating point complex<TD><CODE>#<i>n</i>Ac64</CODE>
<TR><TD><CODE>ac32  </CODE><TD>inexact<TD>IEEE 32.bit floating point complex<TD><CODE>#<i>n</i>Ac32</CODE>
<TR><TD><CODE>ar64  </CODE><TD>inexact<TD>IEEE 64.bit floating point real   <TD><CODE>#<i>n</i>Ar64</CODE>
<TR><TD><CODE>ar32  </CODE><TD>inexact<TD>IEEE 32.bit floating point real   <TD><CODE>#<i>n</i>Ar32</CODE>
<TR><TD><CODE>as64  </CODE><TD>exact  <TD>64.bit integer                    <TD><CODE>#<i>n</i>As64</CODE>
<TR><TD><CODE>as32  </CODE><TD>exact  <TD>32.bit integer                    <TD><CODE>#<i>n</i>As32</CODE>
<TR><TD><CODE>as16  </CODE><TD>exact  <TD>16.bit integer                    <TD><CODE>#<i>n</i>As16</CODE>
<TR><TD><CODE>as8   </CODE><TD>exact  <TD>8.bit integer                     <TD><CODE>#<i>n</i>As8 </CODE>
<TR><TD><CODE>au64  </CODE><TD>exact  <TD>64.bit nonnegative integer        <TD><CODE>#<i>n</i>Au64</CODE>
<TR><TD><CODE>au32  </CODE><TD>exact  <TD>32.bit nonnegative integer        <TD><CODE>#<i>n</i>Au32</CODE>
<TR><TD><CODE>au16  </CODE><TD>exact  <TD>16.bit nonnegative integer        <TD><CODE>#<i>n</i>Au16</CODE>
<TR><TD><CODE>au8   </CODE><TD>exact  <TD>8.bit nonnegative integer         <TD><CODE>#<i>n</i>Au8 </CODE>
<TR><TD><CODE>string</CODE><TD>       <TD>char                              <TD><CODE>#<i>n</i>A\  </CODE>
<TR><TD><CODE>at1   </CODE><TD>       <TD>boolean                           <TD><CODE>#<i>n</i>At  </CODE>
</TABLE>
<P>

<UL>
<LI>The original proposal allowed the "<CODE>1</CODE>" in the
    "<CODE>#1A</CODE>" prefix to be elided.  That exception has been
    removed.
<P>
<LI>In discussions on the

<A HREF="http://srfi.schemers.org/srfi-58/mail-archive/threads.html">
SRFI-58 mailing list</A>, the abbreviations for the original uniform
array types were criticized for being cryptic.  Abbreviations for
<DFN>signed</DFN> and <DFN>unsigned</DFN> were used, even though those
terms are absent from R4RS and R5RS!
<P>
Type names from Scheme foreign-function and foreign-data interfaces
were suggested; but these names are confusing or even misleading to
those unfamiliar with C or Java.
<P>
The Scheme reports are amply descriptive using their succinct
vocabulary; so I rewrote this SRFI to use only Scheme terminology.
Several correspondents felt the resulting full names of the array
types were too long:
<PRE>
  inexact-IEEE-64-bit-floating-point-complex-array
  inexact-IEEE-32-bit-floating-point-complex-array
  inexact-IEEE-64-bit-floating-point-real-array
  inexact-IEEE-32-bit-floating-point-real-array
  exact-64-bit-integer-array
  exact-32-bit-integer-array
  exact-16-bit-integer-array
  exact-8-bit-integer-array
  exact-64-bit-nonnegative-integer-array
  exact-32-bit-nonnegative-integer-array
  exact-16-bit-nonnegative-integer-array
  exact-8-bit-nonnegative-integer-array
  char-array
  boolean-array
  object-array
</PRE>

Per Bothner suggested that the Common-Lisp "<CODE>#<I>n</I>A</CODE>"
prefix could be retained while eschewing further abbreviations by
introducing "<CODE>:</CODE>" into the notation thus
"<CODE>#<I>n</I>A:<I>typename</I></CODE>".
<P>
The short <I>typename</I>s are those suggested by Taylor Campbell
(with the un-Schemely "<CODE>-U</CODE>" and "<CODE>-S</CODE>" replaced
by "<CODE>+</CODE>" and "<CODE>-</CODE>").  The results in
<A HREF="#Table-1">Table-1</A> are compact, mnemonic, and do not reach
outside of the Scheme language.
<P>
<LI>The use of
    <A HREF="http://srfi.schemers.org/srfi-10/srfi-10.html">SRFI-10</A>

    syntax for Arrays was discussed; but I felt the reasons in support
    of the "<CODE>#<I>n</I>A</CODE>" syntax given in the
    <CITE>Rationale</CITE> were more compelling.
<P>
<LI>Common Lisp has a compact notation for rank 1 boolean arrays:
    "<CODE>#*</CODE>" followed by a sequence of ones and zeros;
    "<CODE>1</CODE>" for "<CODE>#t</CODE>", "<CODE>0</CODE>" for
    "<CODE>#f</CODE>".  Common-Lisp's bit-array accessor functions
    return "<CODE>1</CODE>" and "<CODE>0</CODE>"; but SRFI-47's
    "<CODE>array-ref</CODE>" returns "<CODE>#t</CODE>" or "<CODE>#f</CODE>".
    I don't think that difference invalidates this notation for
    Scheme, but others may.
<P>
</UL>

<H1>Rationale</H1>

<UL>
  <LI>
  Vectors, which are rank 1 arrays, have a notation allowing them to
  be read and written by the procedures read and write.  Vectors which
  are written, then read are EQUAL?  to the originals.<P>

  <LI>
  A write-read invariant notation for other arrays would allow them to
  be easily saved and restored by programs.<P>

  <LI>
  A read notation for arrays would allow literal arrays to be coded
  directly in programs.<P>

  <LI>
  The syntax for heterogeneous array constants,
  "<CODE>#<VAR>n</VAR>A</CODE>" followed by the list-decomposition of
  the array, is the same as the Common-Lisp read-syntax for arrays.<P>

  Why Common-Lisp array syntax?  Per Bothner answers:
  <UL>
  <LI>It's terse.<P>
  <LI>It's stylistically consistent with vector notation:<BR>
      "<CODE>#(a b c)</CODE>" can be viewed as short-hand for "<CODE>#1a(a b c)</CODE>".<P>
  <LI>It doesn't require me to write an extra noise keyword.<P>
  <LI>It's prior art.<P>
  </UL>

</UL>

<P>
<A HREF="http://srfi.schemers.org/srfi-47/srfi-47.html">SRFI-47</A>,
"Array", incorporates all the uniform vector types from

<A HREF="http://srfi.schemers.org/srfi-4/srfi-4.html">SFRI-4</A>
"Homogeneous numeric vector datatypes", and adds a boolean array type
and array types of complex numbers composed of two IEEE 32.bit or two
IEEE 64.bit floating-point numbers.  Multi-dimensional arrays subsume
homogeneous vectors as the one-dimensional case, obviating the need
for SRFI-4.
<P>
Implementations are required to accept all of the type denotations.
Those which the platform supports will have platform-dependent
representations; the others will be represented as the next larger
uniform-type implemented; defaulting to <CODE>vector</CODE> if there
are none.
<P>
Aliases for the array-prototype-procedures of SRFI-47 are defined
whose identifiers are the <CODE>#<I>n</I>A:<I>typename</I></CODE>
prefix sans the <CODE>#<I>n</I></CODE>.  Having the
array-prototype-procedure names match the array prefixes reduces the
memory load for users.
<P>
<!-- <BLOCKQUOTE> -->
<!-- <H3>SRFI-47 Clarification</H3> -->
<!-- All implementations must support Scheme strings as rank 1 character -->
<!-- arrays.  This requirement mandates that Scheme strings be valid -->
<!-- arguments to array procedures; the stored representations may be very -->
<!-- different from other character arrays.  Note that Scheme strings may -->
<!-- have indexed access times slower than character arrays or other -->
<!-- arrays.  Note also that character arrays may have slower access times -->
<!-- than Scheme strings or other arrays. -->
<!-- </BLOCKQUOTE> -->
<!-- <P> -->
This arrangement has platforms supporting uniform array types using
them, with less capable platforms using vectors; both from the same
source code.
<P>

<H1>Specification</H1>

<H2>Syntax</H2>

A syntax for arrays is the <DFN>list-decomposition</DFN> of an array
with a prefix according to the type of the array.
<!-- The rank digit `<I>n</I>' is optional for rank 1 arrays. -->
The case of characters is not significant in the prefix characters.
<P>
By <DFN>list-decomposition</DFN> is meant rank nestings of lists of
the elements where the most nested list has length equal to the last
dimension of the array and at top level has length equal to the first
dimension of the array.
<!-- <P> -->
<!-- Rank 1 character arrays which are not subarrays are -->
<!-- <CODE>write</CODE>n as Scheme strings; <CODE>display</CODE> treats -->
<!-- rank 1 character arrays which are not subarrays identically with -->
<!-- strings. -->
<P>
Rank 1 heterogeneous arrays which are not subarrays
<CODE>write</CODE> and <CODE>display</CODE> as Scheme vectors.
<P>
<A NAME=Table-1></A>
<TABLE ALIGN=CENTER BORDER=1>
<TR><TH>prototype<BR>procedure
    <TH>exactness
    <TH>element type
    <TD ALIGN=CENTER><B>prefix</B><BR>(rank = <I>n</I>)
<TR><TD><CODE>vector      </CODE><TD>       <TD>any                               <TD><CODE>#<i>n</i>A           </CODE>
<TR><TD><CODE>A:complex-64</CODE><TD>inexact<TD>IEEE 64.bit floating point complex<TD><CODE>#<i>n</i>A:complex-64</CODE>
<TR><TD><CODE>A:complex-32</CODE><TD>inexact<TD>IEEE 32.bit floating point complex<TD><CODE>#<i>n</i>A:complex-32</CODE>
<TR><TD><CODE>A:real-64   </CODE><TD>inexact<TD>IEEE 64.bit floating point real   <TD><CODE>#<i>n</i>A:real-64   </CODE>
<TR><TD><CODE>A:real-32   </CODE><TD>inexact<TD>IEEE 32.bit floating point real   <TD><CODE>#<i>n</i>A:real-32   </CODE>
<TR><TD><CODE>A:integer-64</CODE><TD>exact  <TD>64.bit integer                    <TD><CODE>#<i>n</i>A:integer-64</CODE>
<TR><TD><CODE>A:integer-32</CODE><TD>exact  <TD>32.bit integer                    <TD><CODE>#<i>n</i>A:integer-32</CODE>
<TR><TD><CODE>A:integer-16</CODE><TD>exact  <TD>16.bit integer                    <TD><CODE>#<i>n</i>A:integer-16</CODE>
<TR><TD><CODE>A:integer-8 </CODE><TD>exact  <TD>8.bit integer                     <TD><CODE>#<i>n</i>A:integer-8 </CODE>
<TR><TD><CODE>A:integer+64</CODE><TD>exact  <TD>64.bit nonnegative integer        <TD><CODE>#<i>n</i>A:integer+64</CODE>
<TR><TD><CODE>A:integer+32</CODE><TD>exact  <TD>32.bit nonnegative integer        <TD><CODE>#<i>n</i>A:integer+32</CODE>
<TR><TD><CODE>A:integer+16</CODE><TD>exact  <TD>16.bit nonnegative integer        <TD><CODE>#<i>n</i>A:integer+16</CODE>
<TR><TD><CODE>A:integer+8 </CODE><TD>exact  <TD>8.bit nonnegative integer         <TD><CODE>#<i>n</i>A:integer+8 </CODE>
<!-- <TR><TD><CODE>string      </CODE><TD>       <TD>char                              <TD><CODE>#<i>n</i>A:char      </CODE> -->
<TR><TD><CODE>A:boolean   </CODE><TD>       <TD>boolean                           <TD><CODE>#<i>n</i>A:boolean   </CODE>
</TABLE>
<P>
A two-by-three array of nonnegative 16.bit integers is written:
<PRE>
#2A:integer+16((0 1 2) (3 5 4))
</PRE>
Note that this is the external representation of an array, not an
expression evaluating to a array.  Like vector constants, array
constants must be quoted:

<PRE>
'#2a:INTEGER+16((0 1 2) (3 5 4))
               ==> #2A:integer+16((0 1 2) (3 5 4))
</PRE>

<H2>Semantics</H2>

<P>
This array could have been created by <CODE>(make-array (A:integer+16) 2 3)</CODE>.
<PRE>
(array-dimensions '#2A:integer+16((0 1 2) (3 5 4))) ==> (2 3)
</PRE>
<P>
Literal array constants are immutable objects.  It is an error to
attempt to store a new value into a location that is denoted by an
immutable object.

<P>
The following equivalences will be defined to alias SRFI-47 names to
the new ones.  SRFI-47 should be amended or replaced to make these be
the array-prototype-procedures:

<PRE>
(define A:complex-64 ac64)
(define A:complex-32 ac32)
(define A:real-64    ar64)
(define A:real-32    ar32)
(define A:integer-64 as64)
(define A:integer-32 as32)
(define A:integer-16 as16)
(define A:integer-8  as8)
(define A:integer+64 au64)
(define A:integer+32 au32)
(define A:integer+16 au16)
(define A:integer+8  au8)
(define A:boolean    at1)
</PRE>
<P>

<H1>Implementation</H1>

The following code from the

<A HREF="http://swiss.csail.mit.edu/~jaffer/SCM">SCM</A>
implementation ("Init5d9.scm") implements array read-syntax.
<CODE>read:sharp</CODE> is called from <CODE>read</CODE> when a
<CODE>#\#</CODE> is read.  Its first argument is the character after
<CODE>#\#</CODE>; the second argument is the input port; the third
argument is the procedure to call for recursive reading.
<P>
<CODE>list-&gt;uniform-array</CODE> converts the list-decomposition
returned by <CODE>read</CODE> into the uniform array of the specified
type (or the next larger compatible type).
<P>
<PRE>
(define (read:sharp c port read)
  (case c
    ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
     (let* ((num (read:try-number port c))
            (c (peek-char port)))
       (cond ((memv c '(#\a #\A))
              (read-char port)
              (read:array num port read))
             (else (error "syntax? #" num c)))))
    (else (error "unknown # object" c))))

(define (read:try-number port . ic)
  (define chr0 (char-&gt;integer #\0))
  (let loop ((arg (and (not (null? ic))
                       (- (char-&gt;integer (car ic)) chr0))))
    (let ((c (peek-char port)))
      (cond ((eof-object? c) #f)
            ((char-numeric? c)
             (loop (+ (* 10 (or arg 0))
                      (- (char-&gt;integer (read-char port)) chr0))))
            (else arg)))))

(define (read:array rank port reader)   ;ignore reader
  (define (bomb pc wid)
    (error (string-append "array syntax? #"
                          (number-&gt;string rank)
                          "A" (string pc)
                          (if wid (number-&gt;string wid) ""))))
  (list-&gt;uniform-array
   rank
   (case (char-downcase (peek-char port))
     ((#\:)
      (read-char port)
      (let ((typ (read port)))
        (case typ
          ((complex-64) +64.0i)
          ((complex-32) +32.0i)
          ((real-64)     64.0)
          ((real-32)     32.0)
          ((integer-64) -64)
          ((integer-32) -32)
          ((integer-16) -16)
          ((integer-8)   -8)
          ((integer+64)  64)
          ((integer+32)  32)
          ((integer+16)  16)
          ((integer+8)    8)
          ((boolean)     #t))))
     (else #f))
   (read port)))
</PRE>
<P>

<H1>Copyright</H1>
Copyright (C) Aubrey Jaffer (2004, 2005). All Rights Reserved.
<P>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined
in the SRFI process must be followed, or as required to translate it
into languages other than English.
<P>
The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.
<P>
This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.


    <HR>
    <ADDRESS>Editor: <A HREF="mailto:srfi-editors@srfi.schemers.org">David Van Horn</A></ADDRESS>
<!-- Created: Tue Sep 29 19:20:08 EDT 1998 -->
<!-- hhmts start -->
Last modified: Mon Jan  3 14:05:53 EST 2005
<!-- hhmts end -->
  </BODY>
</HTML>
