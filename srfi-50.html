<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<body>
<head>
<title>SRFI 50: Mixing Scheme and C</title>
</head>

<body>
<H1>Title</H1>

SRFI 50: Mixing Scheme and C

<H1>Authors</H1>

Richard Kelsey and Michael Sperber

<H1>Status</H1>
    
    This SRFI is currently in ``draft'' status.  To see an explanation
    of each status that a SRFI can hold, see
    <A HREF="http://srfi.schemers.org/srfi-process.html">here</A>.
    It will remain in draft status until 2004/03/25, or as amended.
    To provide input on this SRFI, please
    <CODE><A HREF="mailto:srfi-50@srfi.schemers.org">mail to
    &lt;srfi-50@srfi.schemers.org&gt;</A></CODE>.  See
    <A HREF=../srfi-list-subscribe.html>instructions here</A>
    to subscribe to the list.  You can access previous messages via
    <A HREF=mail-archive/maillist.html>the archive of the mailing list</A>. 
    <P><UL>
      <LI>Received: 2003/12/16
      <LI>Draft: 2003/12/22-2004/03/25
    </UL>

<H1>Abstract</H1>

<p>This SRFI describes an interface for calling C functions from Scheme, calling Scheme functions from C, and allocating storage in the Scheme heap.  Scheme manages stub functions in C that negotiate between the calling conventions of Scheme and C and the memory allocation policies of both worlds. </p><p>The following facilities are available for interfacing between Scheme and C:</p><ul><li>Scheme code can call C functions.</li><li>The external interface provides full introspection for all Scheme objects.  External code may inspect, modify, and allocate Scheme objects arbitrarily.</li><li>External code may signal errors to the Scheme system.</li><li>External code may call back into Scheme.  Scheme correctly unrolls the process stack on non-local exits.</li><li>External modules may register bindings of names to values with a central registry accessible from Scheme.  Conversely, Scheme code can register shared bindings for access by C code.</li></ul><p>The interface is closely based on that of <a href="http://www.s48.org/">Scheme 48</a> and <a href="http://www.scsh.net/">scsh</a>.</p>

<H1>Issues</H1>

<dl><dt><code>SCHEME_EXTRACT_STRING</code></dt><dd><p>Is it always possible to implement <a href="#SCHEME_EXTRACT_STRING"><code>SCHEME_EXTRACT_STRING</code></a> in the manner described? <code>SCHEME_EXTRACT_STRING</code>assumes that it is always possible to return a  pointer to the contents of the string.  Exactly how that contents might be organized is another issue. It may not be possible to use the contents of the string in an implementation-independent fashion.  Efficient portable access to the contents of strings is a difficult issue.</p></dd><dt>String/character encoding</dt><dd><p>This draft does not address the string/character encoding issue at all. Worse, it probably prescribes something that is incompatible with using Unicode or some other wide representation of characters. We don't know enough about the issues involved to speculate on how they should be addressed. They definitely <em>should</em> be addressed, however.</p></dd><dt>Signal handling</dt><dd><p>Signals might occur during the execution of C code. Since Scheme implementations often manage signals themselves, it is not clear how to specify what happens during such an event. This aspect of the C interface is probably best left unspecified.</p></dd><dt>Callbacks</dt><dd><p>For some Scheme implementations, it may be possible to implement calls from Scheme to C in a significantly cheaper manner if callbacks from C into Scheme are forbidden.  Should there be separate versions of <a href="#call-imported-c-binding"><code>call-imported-c-binding</code></a> and <a href="#call-imported-n-ary-c-binding"><code>call-imported-n-ary-c-binding</code></a> forbidding callbacks?</p></dd><dt>Examples</dt><dd><p>More examples will be added once the design has settled down.</p></dd></dl>

<H1>Rationale</H1>

<p>The goal of this SRFI is to facilitate interfacing C libraries with a wide variety of Scheme implementations.To this end, the following criteria were considered in the design of the interface.</p><ul><li>The interface is designed to be completely implementable in ANSI C. For instance, it does not depend on symbol-table introspection or particular policies for C object layout.</li><li>The interface is designed to be compatible with both Scheme interpreters and native-code systems.</li><li>The interface is designed to allow dumping a heap image if the underlying Scheme implementation provides this.</li><li>The interface is designed to be compatible with a wide variety of memory management policies.  In particular, it allows for precise garbage collection, moving garbage collection and collection schemes which require a write barrier.</li><li>The interface is a low-level substrate on which higher-level tools can be built.  In particular, it does not prescribe a stub generator, but allows the implementation of one.</li></ul>

<H1>Specification</H1>

<h2>Requirements</h2>
<p>Scheme implementations supporting this SRFI should also support <a href="http://srfi.schemers.org/srfi-9/">SRFI 9</a> (&quot;Defining Record Types&quot;).</p>

<h2>C naming conventions</h2>
<p>The names of all of Scheme's visible C bindings begin with `<code>scheme_</code>' (for functions and types) or `<code>SCHEME_</code>' (for macros).  Whenever a C name is derived from a Scheme identifier, we replace `<code>-</code>' with `<code>_</code>' and convert letters to lowercase for functions and uppercase for macros. A final `<code>?</code>'  converted to `<code>_p</code>' (`<code>_P</code>' in C macro names). A final `<code>!</code>' is dropped. Thus the C macro for Scheme's <code>pair?</code> is <code>SCHEME_PAIR_P</code> and the one for <code>set-car!</code> is <code>SCHEME_SET_CAR</code>.  Functions and macros that do not check the types of their arguments have `<code>unsafe</code>' in their names.</p>

<h2>Prototypes</h2>
<p>All of the C functions and macros described have prototypes or definitions in the header file <code>srfi-50.h</code> which can be included via <pre>#include &quot;srfi-50.h&quot;
</pre>The C type for Scheme values is defined there to be <code>scheme_value</code>.</p><p>Note that most functionality on the C side is implemented by macros.</p><p>When the type of a value is known, such as the integer returned by <code>vector-length</code> or the boolean returned by <code>pair?</code>, the corresponding C procedure returns a C value of the appropriate type, and not a <code>scheme_value</code>.</p>

<h2>Garbage collection</h2>
<p>The Scheme system may use a copying garbage collector. The collector must be able to locate all references to objects allocated in the Scheme heap in order to ensure that storage is not reclaimed prematurely and to update references to objects moved by the collector. The garbage collector may run whenever an object is allocated in the heap. C variables whose values are Scheme objects and which are live across heap allocation calls need to be registered with the garbage collector.</p>

<h2>Shared bindings</h2>
<p>Shared bindings are the means by which named values are shared between Scheme code and C code. There are two separate tables of shared bindings, one for values defined in Scheme and accessed from C and the other for values going the other way.  Shared bindings actually bind names to cells, to allow a name to be looked up before it has been assigned. This is necessary because C initialization code may be run before or after Scheme initialization code, where one accesses shared bindings created by the other, depending on implementation details of the underlying Scheme system.</p>

<h2>Exporting Scheme values to C</h2>
<dl><dt><code>(define-exported-c-binding </code><var>name</var> <var>value</var><code>)</code></dt><dt><code>scheme_value SCHEME_GET_IMPORTED_BINDING(char *name)</code> (may GC)</dt><dt><code>scheme_value SCHEME_SHARED_BINDING_REF(scheme_value shared_binding)</code></dt><dd><p><code>Define-exported-c-binding</code> makes <var>value</var> available to C code under as <var>name</var> which must be a string , creating a new shared binding if necessary.</p><p>The C macro <code>SCHEME_GET_IMPORTED_BINDING</code> returns the shared binding defined for <code>name</code>, again creating it if necessary.</p><p>The C macro <code>SCHEME_SHARED_BINDING_REF</code> dereferences a shared binding, returning its current value.</p><p>The value of a shared binding that has not been defined is undefined.</p></dd></dl>

<h2>Exporting C values to Scheme</h2>
<dl><dt><a name="SCHEME_DEFINE_EXPORTED_BINDING"><code>void SCHEME_DEFINE_EXPORTED_BINDING(char *name, scheme_value v)</code></a> (may GC)</dt><dt><code>(get-imported-c-binding </code><var>string</var><code>)</code></dt><dt><code>(shared-c-binding-ref </code><var>shared-c-binding</var><code>)</code></dt><dd><p>These are used to define shared bindings from C and to access them from Scheme.  Again, if a name is looked up before it has been defined, a new binding is created for it.</p></dd><dt><code>void SCHEME_EXPORT_FUNCTION(name)</code></dt><dd><p>This macro covers the common case of exporting a C function to Scheme. <code>SCHEME_EXPORT_FUNCTION(<var>name</var>)</code> expands into</p><p><code>scheme_define_exported_binding(&quot;<var>name</var>&quot;, scheme_enter_pointer(<var>name</var>))</code></p><p>which boxes the function into a Scheme object and then exports it. Note that <code>scheme_enter_pointer</code> allocates space in the Scheme heap and might trigger a garbage collection.</p></dd><dt><code>(import-definition </code>&lt;name&gt;<code>)</code> (syntax)</dt><dt><code>(import-definition </code>&lt;name&gt; &lt;c-name&gt;<code>)</code> (syntax)</dt><dd><p>These macros simplify importing definitions from C to Scheme. They expand into</p><p><code>(define &lt;name&gt; (get-imported-c-binding &lt;c-name&gt;</code>))</p><p>where &lt;c-name&gt; is as supplied for the second form.  For the first form &lt;c-name&gt; is derived from &lt;name&gt; by replacing `<code>-</code>' with `<code>_</code>' and converting letters to lowercase.  For example, <code>(import-definition my-foo)</code> expands into</p><p><code>(define my-foo (lookup-imported-c-binding &quot;my_foo&quot;))</code></p></dd></dl><p>It is expected that a piece of C code that provides functions callable from Scheme provide an initialization function that creates exported bindings for these functions. The  mechanism by which the Scheme system calls this initialization function is implementation-dependent.</p>

<h2>Miscellaneous shared binding functionality</h2>
<p>There are a number of other Scheme procedures and C functions related to shared bindings.</p><p>Scheme predicates return <code>#t</code> for true and <code>#f</code> for false.  C predicates return a non-zero value for true and 0  for false.</p><dl><dt><code>(shared-c-binding? </code><var>obj</var><code>)</code></dt><dt><code>int SCHEME_SHARED_BINDING_P(x)</code></dt><dd><p><code>Shared-c-binding?</code> and <code>SCHEME_SHARED_BINDING_P</code> are predicates for shared bindings.</p></dd><dt><code>(shared-c-binding-name </code><var>shared-c-binding</var><code>)</code></dt><dt><code>scheme_value SCHEME_SHARED_BINDING_NAME(scheme_value s_b)</code></dt><dd><p><code>Shared-c-binding-name</code> and <code>SCHEME_SHARED_BINDING_NAME</code> return the name of a binding as  a Scheme string.</p></dd><dt><code>(shared-c-binding-is-import? </code><var>shared-c-binding</var><code>)</code></dt><dt><code>int SCHEME_SHARED_BINDING_IS_IMPORT_P(scheme_value s_b)</code></dt><dd><p><code>Shared-c-binding-is-import?</code> returns <code>#t</code> if the binding was defined from C, <code>#f</code> otherwise.</p><p><code>SCHEME_SHARED_BINDING_IS_IMPORT_P</code> returns a non-zero value if the binding was defined from Scheme, 0 otherwise.</p></dd><dt><code>(shared-c-binding-set! </code><var>shared-c-binding</var> <var>obj</var><code>)</code></dt><dt><code>void SCHEME_SHARED_BINDING_SET(scheme_value s_b, scheme_value v)</code></dt><dd><p><code>Shared-c-binding-set!</code> and <code>SCHEME_SHARED_BINDING_SET</code> change the value of a binding.</p></dd><dt><code>(define-imported-c-binding </code><var>string</var> <var>obj</var><code>)</code></dt><dt><code>(lookup-exported-c-binding </code><var>string</var><code>)</code></dt><dd><p><code>Define-imported-c-binding</code> and <code>lookup-exported-c-binding</code> are Scheme versions of <code>scheme_define_exported_binding</code> and <code>scheme_lookup_imported_binding</code>.</p></dd><dt><code>(undefine-imported-c-binding </code><var>string</var><code>)</code></dt><dt><code>(undefine-exported-c-binding </code><var>string</var><code>)</code></dt><dd><p>The two <code>undefine-</code> procedures remove bindings from the two tables. They do nothing if the name is not found in the table.</p></dd></dl>

<h2>Calling C functions from Scheme</h2>
<dl><dt><a name="call-imported-c-binding"><code>(call-imported-c-binding </code><var>binding</var> <var>arg<sub>1</sub></var> ...<code>)</code></a></dt><dd><p>This applies its first argument, an imported binding containing a C function, to the rest of the arguments.  <var>Binding</var> must be an imported binding that contains a C function pointer converted to a Scheme value via <a href="#SCHEME_ENTER_POINTER"><code>SCHEME_ENTER_POINTER</code></a>. The C function is passed the <var>arg<sub>i</sub></var> values and the value returned is that returned by C procedure. No automatic representation conversion occurs for either arguments or return values. Up to 12 arguments may be passed. </p><p>Note that the C function, if it allocates Scheme heap storage, must register its parameters with the garbage collector.</p><p>There is no method supplied for returning multiple values to Scheme from C (or vice versa) (mainly because C does not have multiple return  values).</p></dd><dt><a name="call-imported-c-binding/variable-arity"><code>(call-imported-c-binding/variable-arity </code><var>binding</var> <var>arg<sub>1</sub></var> ... <var>arg<sub>n</sub></var><code>)</code></a></dt><dd><p>This applies its first argument, an imported binding containing a C function to two arguments:</p><ol><li>the number <i>n</i>, represented as an <code>int</code>.</li><li>an array of type <code>scheme_value []</code> which contains the arguments <var>arg<sub>1</sub></var><code>...</code><var>arg<sub>n</sub></var> in that order.</li></ol><p>Upon entry into the C function, the Scheme objects contained in the array have already been registered with the garbage collector and are deregistered after the C function has returned.</p><p>The C function should not modify the contents of the array.</p></dd><dt><code>(import-lambda-definition  </code>&lt;name&gt; <code>(</code> &lt;variable&gt; ... <code>)</code><code>)</code> (syntax)</dt><dt><code>(import-lambda-definition </code>&lt;name&gt; <code>(</code> &lt;variable&gt; ... <code>)</code> &lt;c-name&gt;<code>)</code> (syntax)</dt><dd><p>These macros simplify importing functions from C. They define &lt;name&gt; to be a procedure with the given parameters that passes their values to the corresponding C binding.&lt;C-name&gt;, if supplied, should be a string. These expand into</p><pre>(define &lt;name&gt;
  (let ((temp (lookup-imported-c-binding &lt;c-name&gt;)))
    (lambda (&lt;variable&gt; ...)
      (call-imported-c-binding temp &lt;variable&gt; ...)))</pre><p>If &lt;c-name&gt; is not supplied, it is derived from &lt;name&gt; by converting all letters to lowercase and replacing `<code>-</code>' with `<code>_</code>'.</p></dd></dl>

<h2>Accessing Scheme data from C</h2>
<h2>Constants</h2>
<p>The following macros denote Scheme constants:</p><dl><dt><code>SCHEME_FALSE</code></dt><dd> is <code>#f</code>.</dd><dt><code>SCHEME_TRUE</code></dt><dd> is <code>#t</code>.</dd><dt><code>SCHEME_NULL</code></dt><dd> is the empty list.</dd><dt><code>SCHEME_UNSPECIFIC</code></dt><dd> is a value used for functions which have no meaningful return value.</dd></dl>

<h2>Converting values</h2>
<p>The following macros convert values between Scheme and C representations. The `EXTRACT' ones convert from Scheme to C and the `ENTER's go the other way.</p><p>All of the `EXTRACT' macros check their arguments.  Upon a type (or range) mismatch, an error is signalled.  (See <a href="#errors">Signalling errors from external code</a>.)</p><dl><dt><code>int SCHEME_EXTRACT_BOOLEAN(scheme_value)</code></dt><dt><code>scheme_value SCHEME_ENTER_BOOLEAN(int)</code></dt><dd><p><code>SCHEME_EXTRACT_BOOLEAN</code> returns 0 if its argument is <code>#f</code> and a non-zero value otherwise.  <code>SCHEME_ENTER_BOOLEAN</code> is <code>#f</code> if its argument is zero and <code>#t</code> otherwise.</p><p><code>SCHEME_ENTER_BOOLEAN</code> returns <code>SCHEME_FALSE</code> if its  argument is 0 and <code>SCHEME_TRUE</code> otherwise:</p></dd><dt><code>char SCHEME_EXTRACT_CHAR(scheme_value)</code></dt><dt><code>scheme_value SCHEME_ENTER_CHAR(char)</code> (may GC)</dt><dd><p><code>SCHEME_EXTRACT_CHAR</code> converts a Scheme character to a C <code>char</code> value.  <code>SCHEME_ENTER_CHAR</code> performs the conversion in the opposite direction.</p></dd><dt><a name="SCHEME_EXTRACT_STRING"><code>char *    SCHEME_EXTRACT_STRING(scheme_value)</code></a></dt><dt><code>scheme_value SCHEME_ENTER_STRING(char *)</code> (may GC)</dt><dd><p><code>SCHEME_EXTRACT_STRING</code> returns a pointer to the actual storage used by the Scheme string.  If this is the case, the pointer is valid only until the next garbage collection.  Note that this string may not be null-terminated; <code>SCHEME_STRING_LENGTH</code> returns the number of characters in the  string.</p><p><code>SCHEME_ENTER_STRING</code> converts its argument, which must be a null-terminated C string, to a Scheme string.  <code>SCHEME_ENTER_STRING</code> copies the characters of its arguments.</p></dd><dt><code>long          SCHEME_EXTRACT_LONG(scheme_value)</code></dt><dt><code>unsigned long SCHEME_EXTRACT_UNSIGNED_LONG(scheme_value)</code></dt><dt><code>int           SCHEME_LONG_P(scheme_value)</code></dt><dt><code>int           SCHEME_UNSIGNED_LONG_P(scheme_value)</code></dt><dt><code>scheme_value  SCHEME_ENTER_LONG(long)</code> (may GC)</dt><dt><code>scheme_value  SCHEME_ENTER_UNSIGNED_LONG(unsigned long)</code> (may GC)</dt><dd><p><code>SCHEME_EXTRACT_LONG</code> extracts the numerical value of  its argument, which must be an exact integer, into a C <code>long</code> value.  <code>SCHEME_EXTRACT_UNSIGNED_LONG</code> extracts the value  into an <code>unsigned long</code> value.</p><p><code>SCHEME_LONG_P</code> and <code>SCHEME_UNSIGNED_LONG_P</code> test whether its argument, which must be an exact integer, is a suitable argument for <code>SCHEME_EXTRACT_LONG</code> or <code>SCHEME_EXTRACT_UNSIGNED_LONG</code>.</p><p>Conversely, <code>SCHEME_ENTER_LONG</code> and <code>SCHEME_ENTER_UNSIGNED_LONG</code> convert a C number to a Scheme exact integer.The <code>SCHEME_ENTER_LONG()</code> and <code>SCHEME_ENTER_UNSIGNED_LONG()</code> macros  may need to allocate storage when the argument is too large to fit in an immediate representation. </p></dd><dt><code>double    SCHEME_EXTRACT_DOUBLE(scheme_value)</code></dt><dt><code>scheme_value SCHEME_ENTER_DOUBLE(double)</code> (may GC)</dt><dd><p><code>SCHEME_EXTRACT_DOUBLE</code> extracts the numerical value of its argument, which must be a real, into a C double value.</p><p>Conversely, <code>SCHEME_ENTER_DOUBLE</code> converts a C double into a Scheme real number.</p></dd><dt><code>void *SCHEME_EXTRACT_POINTER(scheme_value)</code></dt><dt><a name="SCHEME_ENTER_POINTER"><code>scheme_value SCHEME_ENTER_POINTER(void *)</code></a> (may GC)</dt><dd><p><code>SCHEME_ENTER_POINTER</code> creates a Scheme heap object that contains a C pointer. This is useful in conjunction with <a href="#SCHEME_DEFINE_EXPORTED_BINDING"><code>SCHEME_DEFINE_EXPORTED_BINDING</code></a> for representing C functions to be called from Scheme via <a href="#call-imported-c-binding"><code>call-imported-c-binding</code></a>.</p><p><code>SCHEME_EXTRACT_POINTER</code> extracts the C pointer from a value created by <code>SCHEME_ENTER_POINTER</code>.</p></dd></dl>

<h2>C versions of Scheme procedures</h2>
<p>The following macros and procedures are C versions of Scheme procedures. (An alphabetically sorted table follows.</p><dl><dt><code>int       SCHEME_EQ_P(scheme_value, scheme_value)</code></dt><dd><p>is the C version of <code>eq?</code>.</p></dd><dt><code>int       SCHEME_EOF_OBJECT_P(scheme_value, scheme_value)</code></dt><dd><p>is the C version of <code>eof-object?</code>.</p></dd><dt><code>int       SCHEME_CHAR_P(scheme_value)</code></dt><dd><p>is the C version of <code>char?</code>.</p></dd><dt><code>int       SCHEME_INTEGER_P(scheme_value)</code></dt><dd><p>is the C version of <code>integer?</code>.</p></dd><dt><code>int       SCHEME_RATIONAL_P(scheme_value)</code></dt><dd><p>is the C version of <code>rational?</code>.</p></dd><dt><a name="SCHEME_NUMERATOR"><code>scheme_value SCHEME_NUMERATOR(scheme_value)</code></a> (may GC)</dt><dd><p>is the C version of <code>numerator</code>.</p></dd><dt><a name="SCHEME_DENOMINATOR"><code>scheme_value SCHEME_DENOMINATOR(scheme_value)</code></a> (may GC)</dt><dd><p>is the C version of <code>denominator</code>.</p></dd><dt><code>int       SCHEME_REAL_P(scheme_value)</code></dt><dd><p>is the C version of <code>real?</code>.</p></dd><dt><code>scheme_value SCHEME_MAKE_RECTANGULAR(scheme_value, scheme_value)</code> (may GC)</dt><dt><code>scheme_value SCHEME_MAKE_POLAR(scheme_value, scheme_value)</code> (may GC)</dt><dd><p>These are the C equivalents of the <code>make-rectangular</code> and <code>make-polar</code> Scheme procedures.</p></dd><dt><code>scheme_value SCHEME_MAKE_RATIONAL(scheme_value, scheme_value)</code> (may GC)</dt><dd><p><code>SCHEME_MAKE_RATIONAL</code> creates a rational number from two exact integers.  The first argument is the numerator, the second argument is the denominator.</p></dd><dt><code>int       SCHEME_COMPLEX_P(scheme_value)</code></dt><dd><p>is the C version of <code>complex?</code>.</p></dd><dt><a name="SCHEME_REAL_PART"><code>scheme_value SCHEME_REAL_PART(scheme_value)</code></a> (may GC)</dt><dd><p>is the C version of <code>real-part</code>.</p></dd><dt><a name="SCHEME_IMAG_PART"><code>scheme_value SCHEME_IMAG_PART(scheme_value)</code></a> (may GC)</dt><dd><p>is the C version of <code>imag-part</code>.</p></dd><dt><a name="SCHEME_MAGNITUDE"><code>scheme_value SCHEME_MAGNITUDE(scheme_value)</code></a> (may GC)</dt><dd><p>is the C version of <code>magnitude</code>.</p></dd><dt><a name="SCHEME_ANGLE"><code>scheme_value SCHEME_ANGLE(scheme_value)</code></a> (may GC)</dt><dd><p>is the C version of <code>angle</code>.</p></dd><dt><code>int       SCHEME_NUMBER_P(scheme_value)</code></dt><dd><p>is the C version of <code>number?</code>.</p></dd><dt><code>scheme_value SCHEME_EXACT_P(scheme_value)</code></dt><dd><p>is the C version of <code>exact?</code>.</p></dd><dt><code>int       SCHEME_PAIR_P(scheme_value)</code></dt><dd><p>is the C version of <code>pair?</code>.</p></dd><dt><code>scheme_value SCHEME_CAR(scheme_value)</code></dt><dd><p>is the C version of <code>car</code>.</p></dd><dt><code>scheme_value SCHEME_CDR(scheme_value)</code></dt><dd><p>is the C version of <code>cdr</code>.</p></dd><dt><code>void      SCHEME_SET_CAR(scheme_value, scheme_value)</code></dt><dd><p>is the C version of <code>set-car!</code>.</p></dd><dt><code>void      SCHEME_SET_CDR(scheme_value, scheme_value)</code></dt><dd><p>is the C version of <code>set-cdr!</code>.</p></dd><dt><code>scheme_value SCHEME_CONS(scheme_value, scheme_value)</code> (may GC)</dt><dd><p>is the C version of <code>cons</code>.</p></dd><dt><code>int       SCHEME_VECTOR_P(scheme_value)</code></dt><dd><p>is the C version of <code>vector?</code>.</p></dd><dt><code>long      SCHEME_VECTOR_LENGTH(scheme_value)</code></dt><dd><p>is the C version of <code>vector-length</code>.</p></dd><dt><code>scheme_value SCHEME_VECTOR_REF(scheme_value, long)</code></dt><dd><p>is the C version of <code>vector-ref</code>.</p></dd><dt><code>void      SCHEME_VECTOR_SET(scheme_value, long, scheme_value)</code></dt><dd><p>is the C version of <code>vector-set!</code>.</p></dd><dt><code>scheme_value SCHEME_MAKE_VECTOR(long, scheme_value)</code> (may GC)</dt><dd><p>is the C version of <code>make-vector</code>.</p></dd><dt><code>int       SCHEME_STRING_P(scheme_value)</code></dt><dd><p>is the C version of <code>string?</code>.</p></dd><dt><code>long      SCHEME_STRING_LENGTH(scheme_value)</code></dt><dd><p>is the C version of <code>string-length</code>.</p></dd><dt><code>char      SCHEME_STRING_REF(scheme_value, long)</code></dt><dd><p>is the C version of <code>string-ref</code>.</p></dd><dt><code>void      SCHEME_STRING_SET(scheme_value, long, char)</code></dt><dd><p>is the C version of <code>string-set!</code>.</p></dd><dt><code>scheme_value SCHEME_MAKE_STRING(long, char)</code> (may GC)</dt><dd><p>is the C version of <code>make-string</code>.</p></dd><dt><code>int       SCHEME_SYMBOL_P(scheme_value)</code></dt><dd><p>is the C version of <code>symbol?</code>.</p></dd><dt><code>scheme_value SCHEME_SYMBOL_TO_STRING(scheme_value)</code> (may GC)</dt><dd><p>is the C version of <code>symbol-&gt;string</code>.</p></dd></dl><table cellpadding="5" cellspacing="10" border="1" rules="all"><tbody><tr><td>Scheme version</td><td>C version</td><td>Can GC?</td></tr><tr><td><code>angle</code></td><td><code>SCHEME_ANGLE</code></td><td>yes</td></tr><tr><td><code>car</code></td><td><code>SCHEME_CAR</code></td><td>no</td></tr><tr><td><code>cdr</code></td><td><code>SCHEME_CDR</code></td><td>no</td></tr><tr><td><code>char?</code></td><td><code>SCHEME_CHAR_P</code></td><td>no</td></tr><tr><td><code>complex?</code></td><td><code>SCHEME_COMPLEX_P</code></td><td>no</td></tr><tr><td><code>cons</code></td><td><code>SCHEME_CONS</code></td><td>yes</td></tr><tr><td><code>denominator</code></td><td><code>SCHEME_DENOMINATOR</code></td><td>yes</td></tr><tr><td><code>eof-object?</code></td><td><code>SCHEME_EOF_OBJECT_P</code></td><td>no</td></tr><tr><td><code>eq?</code></td><td><code>SCHEME_EQ_P</code></td><td>no</td></tr><tr><td><code>exact?</code></td><td><code>SCHEME_EXACT_P</code></td><td>no</td></tr><tr><td><code>imag-part</code></td><td><code>SCHEME_IMAG_PART</code></td><td>yes</td></tr><tr><td><code>integer?</code></td><td><code>SCHEME_INTEGER_P</code></td><td>no</td></tr><tr><td><code>make-polar</code></td><td><code>SCHEME_MAKE_POLAR</code></td><td>yes</td></tr><tr><td><code>make-rational</code></td><td><code>SCHEME_MAKE_RATIONAL</code></td><td>yes</td></tr><tr><td><code>make-rectangular</code></td><td><code>SCHEME_MAKE_RECTANGULAR</code></td><td>yes</td></tr><tr><td><code>make-string</code></td><td><code>SCHEME_MAKE_STRING</code></td><td>yes</td></tr><tr><td><code>make-vector</code></td><td><code>SCHEME_MAKE_VECTOR</code></td><td>yes</td></tr><tr><td><code>number?</code></td><td><code>SCHEME_NUMBER_P</code></td><td>no</td></tr><tr><td><code>numerator</code></td><td><code>SCHEME_NUMERATOR</code></td><td>yes</td></tr><tr><td><code>pair?</code></td><td><code>SCHEME_PAIR_P</code></td><td>no</td></tr><tr><td><code>rational?</code></td><td><code>SCHEME_RATIONAL_P</code></td><td>no</td></tr><tr><td><code>real?</code></td><td><code>SCHEME_REAL_P</code></td><td>no</td></tr><tr><td><code>real-part</code></td><td><code>SCHEME_REAL_PART</code></td><td>yes</td></tr><tr><td><code>set-car!</code></td><td><code>SCHEME_SET_CAR</code></td><td>no</td></tr><tr><td><code>set-cdr!</code></td><td><code>SCHEME_SET_CDR</code></td><td>no</td></tr><tr><td><code>string?</code></td><td><code>SCHEME_STRING_P</code></td><td>no</td></tr><tr><td><code>string-length</code></td><td><code>SCHEME_STRING_LENGTH</code></td><td>no</td></tr><tr><td><code>string-ref</code></td><td><code>SCHEME_STRING_REF</code></td><td>no</td></tr><tr><td><code>string-set!</code></td><td><code>SCHEME_STRING_SET</code></td><td>no</td></tr><tr><td><code>symbol-&gt;string</code></td><td><code>SCHEME_SYMBOL_TO_STRING</code></td><td>yes</td></tr><tr><td><code>vector?</code></td><td><code>SCHEME_VECTOR_P</code></td><td>no</td></tr><tr><td><code>vector-ref</code></td><td><code>SCHEME_REF</code></td><td>no</td></tr><tr><td><code>vector-set!</code></td><td><code>SCHEME_SET</code></td><td>no</td></tr></tbody></table>

<h2>Calling Scheme procedures from C</h2>
<p>External code can call back to Scheme procedures using the following macro.</p><dl><dt><code>scheme_value SCHEME_CALL(scheme_value p, long nargs, ...)</code> (may GC)</dt><dd><p>This calls the Scheme procedure <code>p</code> on <code>nargs</code> arguments, which are passed as additional arguments to <code>scheme_call</code>.  There may be at most twelve arguments. The value returned by the Scheme procedure is returned by the C procedure. Invoking any Scheme procedure may potentially cause a garbage collection.</p></dd></dl><p>There are some complications that occur when mixing calls from C to Scheme with continuations and threads. C only supports downward continuations (via <code>longjmp()</code>).  Scheme continuations that capture a portion of the C stack have to follow the same restriction.  For example, suppose Scheme procedure <code>s0</code> captures continuation <code>a</code> and then calls C procedure <code>c0</code>, which in turn calls Scheme procedure <code>s1</code>.  Procedure <code>s1</code> can safely call the continuation <code>a</code>, because that is a downward use.  When <code>a</code> is called Scheme will remove the portion of the C stack used by the call to <code>c0</code>.  On the other hand, if <code>s1</code> captures a continuation, that continuation cannot be used from <code>s0</code>, because by the time control returns to <code>s0</code> the C stack used by <code>c0</code> will no longer be valid.  An attempt to invoke an upward continuation that is closed over a portion of the C stack will raise an exception.</p><p>In Scheme, if threads are implemented using continuations, the downward restriction applies to them as well.  An attempt to return from Scheme to C at a time when the appropriate C frame is not on top of the C stack will cause the current thread to block until the frame is available. For example, suppose thread <code>t0</code> calls a C procedure which calls back to Scheme, at which point control switches to thread <code>t1</code>, which also calls C and then back to Scheme.  At this point both <code>t0</code> and <code>t1</code> have active calls to C on the  C stack, with <code>t1</code>'s C frame above <code>t0</code>'s.  If thread <code>t0</code> attempts to return from Scheme to C it will block, as its frame is not accessible. Once <code>t1</code> has returned to C and from there to Scheme, <code>t0</code> will be able to resume. The return to Scheme is required because context switches can only occur while Scheme code is running.  <code>T0</code> will also be able to resume if <code>t1</code> uses a continuation to throw past its call to C.</p>

<h2>Interacting with the Scheme heap</h2>
<p>Any procedure that allocates objects within the Scheme heap may trigger a garbage collection. Variables bound to values in the Scheme heap need to be registered with the garbage collector so that the value will be retained and so that the variables will be updated if the garbage collector moves the object.  The garbage collector has no facility for updating pointers to the interiors of objects.  Consequently, such pointers, such as the ones returned by <code>EXTRACT_STRING</code>, will likely become invalid when a garbage collection occurs.</p>

<h3>Registering objects with the Garbage Collector</h3>
<p>A set of macros are used to manage the registration of automatic variables  and parameters with the garbage collector.</p><dl><dt><code>SCHEME_DECLARE_GC_PROTECT(&lt;n&gt;)</code></dt><dd><p><code>SCHEME_DECLARE_GC_PROTECT(&lt;n&gt;)</code>, where  1 &lt;= <code>&lt;n&gt;</code> &lt; = 12, expands into a declaration which allocates storage for registering &lt;n&gt; variables.  At most one use of <code>SCHEME_DECLARE_GC_PROTECT</code> may occur in a block.</p></dd><dt><code>SCHEME_GC_PROTECT_&lt;n&gt;(&lt;scheme_value<sub>1</sub>&gt;, ..., &lt;scheme_value<sub>n</sub>&gt;)</code></dt><dd><p>This expands into a statement which registers the &lt;n&gt; variables (lvalues) with the garbage collector. It must be within scope of a <code>SCHEME_DECLARE_GC_PROTECT(<i>n</i>)</code> and be before any code which can cause a GC.</p><p>Note that the variables to be protected must be initialized. (With <code>SCHEME_UNSPECIFIC</code>, for instance.)Otherwise, program behavior is unspecified.</p></dd><dt><code>SCHEME_GC_UNPROTECT()</code></dt><dd><p><code>SCHEME_GC_UNPROTECT</code> expands into a statement which removes the block's protected variables from the garbage collector's list. It must be called at the end of the block after any code which may cause a garbage collection. Omitting any of the three may cause serious and hard-to-debug problems. Notably, the garbage collector may relocate protected objects and invalidate <code>scheme_value</code> variables which are not protected.</p></dd></dl><p>It is an error when a C procedure returns to Scheme, the calls to <code>SCHEME_GC_PROTECT()</code> have not been matched by an equal number of calls to <code>SCHEME_GC_UNPROTECT()</code>.</p><p>Global variables may also be registered with the garbage collector.</p><dl><dt><code>SCHEME_GC_PROTECT_GLOBAL(&lt;value&gt;)</code></dt><dd><p><code>SCHEME_GC_PROTECT_GLOBAL</code> expands into a statement which permanently registers the variable &lt;value&gt; (an l-value) with the garbage collector.</p></dd><dt><code>SCHEME_GC_UNPROTECT_GLOBAL(&lt;value&gt;)</code></dt><dd><p><code>SCHEME_GC_UNPROTECT_GLOBAL</code> expands into a statement which deregisters the variable &lt;value&gt; (an l-value) with the garbage collector.</p></dd></dl>

<h2>Keeping C data structures in the Scheme heap</h2>
<p>The following macros can be used to create and access C objects embedded inside Scheme objects:</p><dl><dt><code>scheme_value SCHEME_MAKE_VALUE(type)</code> (may GC)</dt><dt><code>type      SCHEME_EXTRACT_VALUE(scheme_value, type)</code></dt><dt><code>type *    SCHEME_EXTRACT_VALUE_POINTER(scheme_value, type)</code></dt><dt><code>void      SCHEME_SET_VALUE(scheme_value, type, value)</code></dt><dt><code>scheme_value SCHEME_MAKE_AND_SET_VALUE(type, value)</code> (may GC)</dt><dd><p><code>SCHEME_MAKE_VALUE</code> makes a Scheme object large enough to hold an object whose C type is <code>type</code>. <code>SCHEME_EXTRACT_VALUE</code> returns the contents of such an object cast to <code>type</code>, and <code>SCHEME_EXTRACT_VALUE_POINTER</code> returns a pointer to the contents of such an object. The value returned by <code>SCHEME_EXTRACT_VALUE_POINTER</code> is valid only until the next garbage collection.</p><p><code>SCHEME_SET_VALUE</code> stores <code>value</code> into an object created by <code>SCHEME_MAKE_VALUE</code>.</p><p><code>SCHEME_MAKE_AND_SET_VALUE</code> combines <code>SCHEME_MAKE_VALUE</code> and <code>SCHEME_SET_VALUE</code>.</p></dd></dl>

<h2>C code and heap images</h2>
<p>Some Scheme systems use dumped heap images to restore a previous system state.  Such a scheme heap may be written into a file in a machine-independent and operating-system-independent format. The procedures described above may be used to create objects in the Scheme heap that contain information specific to the current machine, operating system, or process. A heap image containing such objects may not work correctly  when resumed.</p><p>To address this problem, a record type may be given a `resumer' procedure. On startup, the resumer procedure for a type is applied to each record of that type in the image being restarted. This procedure can update the record in a manner appropriate to the machine, operating system, or process used to resume the image.</p><dl><dt><code>(define-record-resumer </code>&lt;record-type&gt; &lt;procedure&gt;<code>)</code> (syntax)</dt><dd><p><code>Define-record-resumer</code> defines &lt;procedure&gt;, which should accept one argument, to be the resumer for &lt;record-type&gt;.  The order in which resumer procedures are called is not specified.</p></dd><p>The &lt;procedure&gt; argument to <code>define-record-resumer</code> may be <code>#f</code>, in which case records of the given type are not written out in heap images.</p><p>When writing a heap image which would contain a reference to such a record, the Scheme implementation may refuse to write the image.  If it does write the image, the effects of loading it back in are undefined.</p></dl>

<h2>Using Scheme records in C code</h2>
<p>External modules can create <a href="http://srfi.schemers.org/srfi-9/">SRFI 9</a> records and access their slots positionally.</p><dl><dt><code>scheme_value SCHEME_MAKE_RECORD(scheme_value)</code> (may GC)</dt><dt><code>int       SCHEME_RECORD_P(scheme_value)</code></dt><dt><code>scheme_value SCHEME_RECORD_HAS_TYPE_P(scheme_value record, scheme_value record_type)</code></dt><dt><code>int       SCHEME_CHECK_RECORD_TYPE(scheme_value, scheme_value int)</code></dt><dt><code>scheme_value SCHEME_RECORD_REF(scheme_value, long)</code></dt><dt><code>void      SCHEME_RECORD_SET(scheme_value, long, scheme_value)</code></dt><dd><p>The argument to <code>SCHEME_MAKE_RECORD</code> should be a shared binding whose value is a record type. In C, the fields of Scheme records are only accessible via offsets, with the first field having offset zero, the second offset one, and so forth. If the order of the fields is changed in the Scheme definition of the record type the C code must be updated as well.</p></dd></dl><p>Note that the variables <code>a</code> and <code>b</code> must be protected against the possibility of a garbage collection occuring during  the call to <code>SCHEME_MAKE_RECORD()</code>.</p>

<a name="errors"><h2>Signalling errors from external code</h2></a>
<p>The following macros explicitly signal certain errors, and immediately return to Scheme.  Signalling an error performs all necessary clean-up actions to properly return to Scheme, including adjusting the stack of protected variables.  Besides that, the actual effect of signalling an error is undefined.  (It is expected that a future SRFI will deal with the issue of handling error situations resulting from bugs in the program.</p><dl><dt><code>void SCHEME_ARITY_ERROR(int min, int max)</code></dt><dd><p>This signals that Scheme tried to call a C procedure with the wrong number of arguments.  The <code>min</code> and <code>max</code> arguments denote the minimum and maximum number that the function could accept, respectively.</p></dd><dt><code>void SCHEME_ARGUMENT_TYPE_ERROR(int arg_pos, char *expected_explanation)</code></dt><dd><p>This signals that Scheme passed an argument of a wrong type to a C procedure. The <code>arg_pos</code> argument specifies the position of the invalid argument (0-based).  The <code>expected_explanation</code> text contains a human-readable description of the type the function did actually expect.</p><p>Note to implementors: The C function is not required to provide non-local storage for the explanation.  Therefore, unwinding the stack may destroy the string.</p></dd><dt><code>void SCHEME_OUT_OF_MEMORY_ERROR(void)</code></dt><dd><p>This signals that the C function ran out of memory.</p></dd></dl><dl><dt><code>void SCHEME_CHECK_BOOLEAN(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_SYMBOL(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_PAIR(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_VECTOR(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_STRING(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_CHAR(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_INTEGER(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_RATIONAL(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_REAL(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_COMPLEX(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_NUMBER(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_RECORD(scheme_value, int)</code></dt><dt><code>void SCHEME_CHECK_SHARED_BINDING(scheme_value, int)</code></dt><dd><p>These macros raise argument type errors if their first argument does not have the required type.  The second argument is the argument position passed to <code>scheme_argument_type_error</code> in the case of an error.</p><p><code>SCHEME_CHECK_BOOLEAN</code> raises an error if its argument is neither <code>#t</code> or <code>#f</code>.</p></dd></dl>

<h2>Unsafe macros</h2>
<p>All of the C procedures and macros described above check that their arguments have the appropriate types and that indexes are in range. The following procedures and macros are identical to those described above, except that they do not perform type and range checks. They are provided for the purpose of writing more efficient code; their general use is not recommended.  If a program supplies a value of the wrong type to one of these macros, program behavior is undefined.</p><dl><dt><code>char      SCHEME_UNSAFE_EXTRACT_CHAR(scheme_value)</code></dt><dt><code>char *    SCHEME_UNSAFE_EXTRACT_STRING(scheme_value)</code></dt><dt><code>long      SCHEME_UNSAFE_EXTRACT_LONG(scheme_value)</code></dt><dt><code>unsigned long SCHEME_UNSAFE_EXTRACT_UNSIGNED_LONG(scheme_value)</code></dt><dt><code>double    SCHEME_UNSAFE_EXTRACT_DOUBLE(scheme_value)</code></dt><dt><code>scheme_value SCHEME_UNSAFE_NUMERATOR(scheme_value)</code> (may GC)</dt><dt><code>scheme_value SCHEME_UNSAFE_DENOMINATOR(scheme_value)</code> (may GC)</dt><dt><code>scheme_value SCHEME_UNSAFE_REAL_PART(scheme_value)</code> (may GC)</dt><dt><code>scheme_value SCHEME_UNSAFE_IMAG_PART(scheme_value)</code> (may GC)</dt><dt><code>scheme_value SCHEME_UNSAFE_MAGNITUDE(scheme_value)</code> (may GC)</dt><dt><code>scheme_value SCHEME_UNSAFE_ANGLE(scheme_value)</code> (may GC)</dt><dt><code>scheme_value SCHEME_UNSAFE_CAR(scheme_value)</code></dt><dt><code>scheme_value SCHEME_UNSAFE_CDR(scheme_value)</code></dt><dt><code>void      SCHEME_UNSAFE_SET_CAR(scheme_value, scheme_value)</code></dt><dt><code>void      SCHEME_UNSAFE_SET_CDR(scheme_value, scheme_value)</code></dt><dt><code>long      SCHEME_UNSAFE_VECTOR_LENGTH(scheme_value)</code></dt><dt><code>scheme_value SCHEME_UNSAFE_VECTOR_REF(scheme_value, long)</code></dt><dt><code>void      SCHEME_UNSAFE_VECTOR_SET(scheme_value, long, scheme_value)</code></dt><dt><code>long      SCHEME_UNSAFE_STRING_LENGTH(scheme_value)</code></dt><dt><code>char      SCHEME_UNSAFE_STRING_REF(scheme_value, long)</code></dt><dt><code>void      SCHEME_UNSAFE_STRING_SET(scheme_value, long, char)</code></dt><dt><code>scheme_value SCHEME_UNSAFE_SYMBOL_TO_STRING(scheme_value)</code> (may GC)</dt><dt><code>scheme_value SCHEME_UNSAFE_SHARED_BINDING_REF(scheme_value s_b)</code></dt><dt><code>int       SCHEME_UNSAFE_SHARED_BINDING_P(x)</code></dt><dt><code>int       SCHEME_UNSAFE_SHARED_BINDING_IS_IMPORT_P(scheme_value s_b)</code></dt><dt><code>scheme_value SCHEME_UNSAFE_SHARED_BINDING_NAME(scheme_value s_b)</code></dt><dt><code>void      SCHEME_UNSAFE_SHARED_BINDING_SET(scheme_value s_b, scheme_value value)</code></dt><dt><code>scheme_value SCHEME_UNSAFE_RECORD_TYPE(scheme_value)</code></dt><dt><code>scheme_value SCHEME_UNSAFE_RECORD_REF(scheme_value, long)</code></dt><dt><code>void      SCHEME_UNSAFE_RECORD_SET(scheme_value, long, scheme_value)</code></dt><dt><code>type      SCHEME_UNSAFE_EXTRACT_VALUE(scheme_value, type)</code></dt><dt><code>type *    SCHEME_UNSAFE_EXTRACT_VALUE_POINTER(scheme_value, type)</code></dt><dt><code>void      SCHEME_UNSAFE_SET_VALUE(scheme_value, type, value)</code></dt></dl>

<H1>Examples</H1>
<h2>Creating records in C</h2>
<p>Given the following <a href="http://srfi.schemers.org/srfi-9/">SRFI 9</a> record-type definition</p><pre>(define-record-type :thing
  (make-thing a b)
  thing?
  (a thing-a)
  (b thing-b))
</pre><p> the identifier <code>:thing</code> is bound to the record type and can be exported to C:</p><pre>(define-exported-c-binding &quot;thing-record-type&quot; :thing)
</pre><p><code>Thing</code> records can then be made in C:</p><pre>static scheme_value
  thing_record_type_binding = SCHEME_UNSPECIFIC;

void initialize_things(void)
{
  SCHEME_GC_PROTECT_GLOBAL(thing_record_type_binding);
  thing_record_type_binding =
     SCHEME_GET_IMPORTED_BINDING(&quot;thing-record-type&quot;);
}

scheme_value make_thing(scheme_value a, scheme_value b)
{
  scheme_value thing;
  SCHEME_DECLARE_GC_PROTECT(2);

  SCHEME_GC_PROTECT_2(a, b);

  thing = SCHEME_MAKE_RECORD(thing_record_type_binding);
  SCHEME_RECORD_SET(thing, 0, a);
  SCHEME_RECORD_SET(thing, 1, b);

  SCHEME_GC_UNPROTECT();

  return thing;
}
</pre>

<H1>References</H1>
<ul><li>The &quot;Mixing Scheme 48 and C&quot; chapter by Mike Sperber and Richard Kelsey in the <a href="http://www.s48.org/0.57/manual/s48manual.html"><i>The Incomplete Scheme 48 Reference Manual for release 0.57</i></a> by Richard Kelsey and Jonathan Rees</li><li>The &quot;Interface to C&quot; chapter in the <a href="http://www.iro.umontreal.ca/~gambit/doc/gambit-c_toc.html"><i>Gambit-C manual</i></a> by Marc Feeley</li><li><a href="http://www-rn.informatik.uni-bremen.de/software/elk/doc/cprog.html">Building Extensible Applications with Elk --
C/C++ Programmer's Manual</a> by Oliver Laumann</li><li><i>Inside PLT MzScheme</i> by Matthew Flatt, available from <a href="http://download.plt-scheme.org/doc/">this page</a>.</li><li>The &quot;Interfacing C with Objective Caml&quot; chapter in the <a href="http://caml.inria.fr/ocaml/htmlman/index.html"><i>An introduction to Objective Caml</i></a> by Xavier Leroy</li><li><a href="http://java.sun.com/docs/books/tutorial/native1.1/"><i>Java Native Interface Trail</i></a> by Beth Stearns</li><li><a href="http://www.cse.unsw.edu.au/~chak/haskell/ffi/"><i> The Haskell 98 Foreign Function Interface 1.0</i></a> edited by Manuel Chakravarty</li></ul></body>

<H1>Copyright</H1>
<p>Copyright (C) Richard Kelsey and Michael Sperber (2003). All Rights Reserved. 
</p>
<p>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</p>
<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p>
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>


    <hr>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">David Rush</a></address>
</body></html>
